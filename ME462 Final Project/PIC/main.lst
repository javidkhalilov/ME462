CCS PCH C Compiler, Version 4.038, 62426               02-Jul-11 10:52

               Filename: C:\Users\cavid\Desktop\ME 462 Final Project\PIC\main.lst

               ROM used: 5008 bytes (15%)
                         Largest free fragment is 23660
               RAM used: 566 (28%) at main() level
                         615 (30%) worst case
               Stack:    11 worst case (4 in main + 7 for interrupts)

*
1000:  GOTO   221A
*
1008:  MOVWF  05
100A:  MOVFF  FD8,06
100E:  MOVFF  FE0,07
1012:  MOVLB  0
1014:  MOVFF  FE9,0D
1018:  MOVFF  FEA,08
101C:  MOVFF  FE1,09
1020:  MOVFF  FE2,0A
1024:  MOVFF  FD9,0B
1028:  MOVFF  FDA,0C
102C:  MOVFF  FF3,14
1030:  MOVFF  FF4,15
1034:  MOVFF  FFA,16
1038:  MOVFF  00,0F
103C:  MOVFF  01,10
1040:  MOVFF  02,11
1044:  MOVFF  03,12
1048:  MOVFF  04,13
104C:  BTFSS  FF2.4
104E:  GOTO   1058
1052:  BTFSC  FF2.1
1054:  GOTO   1B74
1058:  BTFSS  FA0.5
105A:  GOTO   1064
105E:  BTFSC  FA1.5
1060:  GOTO   1B0A
1064:  MOVFF  0F,00
1068:  MOVFF  10,01
106C:  MOVFF  11,02
1070:  MOVFF  12,03
1074:  MOVFF  13,04
1078:  BSF    0E.7
107A:  MOVFF  0D,FE9
107E:  MOVFF  08,FEA
1082:  MOVFF  09,FE1
1086:  MOVFF  0A,FE2
108A:  MOVFF  0B,FD9
108E:  MOVFF  0C,FDA
1092:  MOVFF  14,FF3
1096:  MOVFF  15,FF4
109A:  MOVFF  16,FFA
109E:  MOVF   05,W
10A0:  MOVFF  07,FE0
10A4:  MOVFF  06,FD8
10A8:  RETFIE 0
.................... #include "main.h" 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES XT                       //Crystal osc <= 4mhz 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES XINST                    //Extended set extension and Indexed Addressing mode enabled 
.................... #FUSES PLL12                    //Divide By 12(48MHz oscillator input) 
.................... #FUSES CPUDIV4                  //System Clock by 4 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
.................... #FUSES ICPRT                    //ICPRT enabled 
....................  
.................... #use delay(clock=20000000) 
*
21AA:  CLRF   FEA
21AC:  MOVLW  35
21AE:  MOVWF  FE9
21B0:  MOVF   FEF,W
21B2:  BZ    21CE
21B4:  MOVLW  06
21B6:  MOVWF  01
21B8:  CLRF   00
21BA:  DECFSZ 00,F
21BC:  BRA    21BA
21BE:  DECFSZ 01,F
21C0:  BRA    21B8
21C2:  MOVLW  7B
21C4:  MOVWF  00
21C6:  DECFSZ 00,F
21C8:  BRA    21C6
21CA:  DECFSZ FEF,F
21CC:  BRA    21B4
21CE:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
....................  
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    int size; 
....................    int next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    int size; 
....................    long next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    long size; 
....................    long next; }node_t; 
.................... #endif 
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
.................... node_t * create_node(long size,node_t *ptr ) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
*
1B7E:  MOVFF  47,49
1B82:  MOVFF  46,48
....................    result->size=size; 
1B86:  MOVFF  48,FE9
1B8A:  MOVFF  49,FEA
1B8E:  MOVFF  45,FEC
1B92:  MOVF   FED,F
1B94:  MOVFF  44,FEF
....................    result->next = NULL; 
1B98:  MOVLW  02
1B9A:  ADDWF  48,W
1B9C:  MOVWF  FE9
1B9E:  MOVLW  00
1BA0:  ADDWFC 49,W
1BA2:  MOVWF  FEA
1BA4:  CLRF   FEC
1BA6:  MOVF   FED,F
1BA8:  CLRF   FEF
....................    return result; 
1BAA:  MOVFF  48,01
1BAE:  MOVFF  49,02
.................... } 
1BB2:  GOTO   1CF4 (RETURN)
.................... void update_node(node_t *node,long size) // update the size of given node 
.................... { 
....................    node->size=size; 
*
1C38:  MOVF   3E,W
1C3A:  MOVWF  FE9
1C3C:  MOVFF  3F,FEA
1C40:  MOVFF  41,FEC
1C44:  MOVF   FED,F
1C46:  MOVFF  40,FEF
.................... } 
1C4A:  RETLW  00
.................... #define csize 32768 
.................... #define pos 15 
.................... #else 
.................... node_t * create_node(int size,node_t *ptr ) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
....................  
.................... void update_node(node_t *node,int size)// update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... #define csize 128 
.................... #define pos 7 
.................... #endif 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place,node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
*
1BB6:  MOVLW  02
1BB8:  ADDWF  3C,W
1BBA:  MOVWF  FE9
1BBC:  MOVLW  00
1BBE:  ADDWFC 3D,W
1BC0:  MOVWF  FEA
1BC2:  MOVFF  FEC,41
1BC6:  MOVF   FED,F
1BC8:  MOVFF  FEF,40
1BCC:  MOVF   40,F
1BCE:  BNZ   1BE8
1BD0:  MOVF   41,F
1BD2:  BNZ   1BE8
....................        node->next= NULL; 
1BD4:  MOVLW  02
1BD6:  ADDWF  3E,W
1BD8:  MOVWF  FE9
1BDA:  MOVLW  00
1BDC:  ADDWFC 3F,W
1BDE:  MOVWF  FEA
1BE0:  CLRF   FEC
1BE2:  MOVF   FED,F
1BE4:  CLRF   FEF
....................     else 
1BE6:  BRA    1C1E
....................        node->next=place->next; 
1BE8:  MOVLW  02
1BEA:  ADDWF  3E,W
1BEC:  MOVWF  01
1BEE:  MOVLW  00
1BF0:  ADDWFC 3F,W
1BF2:  MOVWF  03
1BF4:  MOVWF  41
1BF6:  MOVLW  02
1BF8:  ADDWF  3C,W
1BFA:  MOVWF  FE9
1BFC:  MOVLW  00
1BFE:  ADDWFC 3D,W
1C00:  MOVWF  FEA
1C02:  MOVFF  FEC,03
1C06:  MOVF   FED,F
1C08:  MOVFF  FEF,42
1C0C:  MOVFF  41,FEA
1C10:  MOVFF  01,FE9
1C14:  MOVFF  03,FEC
1C18:  MOVF   FED,F
1C1A:  MOVFF  42,FEF
....................     place->next=node; 
1C1E:  MOVLW  02
1C20:  ADDWF  3C,W
1C22:  MOVWF  FE9
1C24:  MOVLW  00
1C26:  ADDWFC 3D,W
1C28:  MOVWF  FEA
1C2A:  MOVFF  3F,FEC
1C2E:  MOVF   FED,F
1C30:  MOVFF  3E,FEF
.................... } 
1C34:  GOTO   1D0E (RETURN)
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     printf( "\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................         printf( "%lx--%x--\n\r",node,node->size); 
....................     printf( "size of node_t %u\r\n",sizeof(node_t)); 
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    long nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      if(!bit_test(node->size,pos))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(long)node->next; 
....................          if(!bit_test(temp->size,pos)&& (temp==((long)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    long nsize; 
....................    node=__DYNAMIC_HEAD; 
*
1C4C:  MOVFF  1A,37
1C50:  MOVFF  19,36
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
1C54:  MOVF   36,F
1C56:  BNZ   1C5E
1C58:  MOVF   37,F
1C5A:  BTFSC  FD8.2
1C5C:  BRA    1D60
....................       if(!bit_test(node->size,pos) && node->size >=size) // node is free and > = req size 
1C5E:  MOVFF  36,FE9
1C62:  MOVFF  37,FEA
1C66:  MOVFF  FEC,3D
1C6A:  MOVF   FED,F
1C6C:  MOVFF  FEF,3C
1C70:  BTFSC  3D.7
1C72:  BRA    1D44
1C74:  MOVFF  36,FE9
1C78:  MOVFF  37,FEA
1C7C:  MOVFF  FEC,3E
1C80:  MOVF   FED,F
1C82:  MOVFF  FEF,3D
1C86:  MOVF   3E,F
1C88:  BNZ   1C90
1C8A:  MOVF   35,W
1C8C:  SUBWF  3D,W
1C8E:  BNC   1D44
....................       { 
....................          nsize=node->size; 
1C90:  MOVFF  36,FE9
1C94:  MOVFF  37,FEA
1C98:  MOVFF  FEC,03
1C9C:  MOVF   FED,F
1C9E:  MOVFF  FEF,3A
1CA2:  MOVFF  03,3B
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
1CA6:  MOVLW  04
1CA8:  ADDWF  35,W
1CAA:  MOVF   3B,F
1CAC:  BNZ   1CB4
1CAE:  SUBWF  3A,W
1CB0:  BZ    1D28
1CB2:  BNC   1D28
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(long)node+sizeof(node_t)+size); 
1CB4:  MOVF   35,W
1CB6:  SUBWF  3A,W
1CB8:  MOVWF  3C
1CBA:  MOVLW  00
1CBC:  SUBWFB 3B,W
1CBE:  MOVWF  3D
1CC0:  MOVLW  04
1CC2:  SUBWF  3C,W
1CC4:  MOVWF  3E
1CC6:  MOVLW  00
1CC8:  SUBWFB 3D,W
1CCA:  MOVWF  3F
1CCC:  MOVLW  04
1CCE:  ADDWF  36,W
1CD0:  MOVWF  40
1CD2:  MOVLW  00
1CD4:  ADDWFC 37,W
1CD6:  MOVWF  41
1CD8:  MOVF   35,W
1CDA:  ADDWF  40,W
1CDC:  MOVWF  42
1CDE:  MOVLW  00
1CE0:  ADDWFC 41,W
1CE2:  MOVWF  43
1CE4:  MOVFF  3F,45
1CE8:  MOVFF  3E,44
1CEC:  MOVWF  47
1CEE:  MOVFF  42,46
1CF2:  BRA    1B7E
1CF4:  MOVFF  02,39
1CF8:  MOVFF  01,38
....................             insert_node_after(node,new); 
1CFC:  MOVFF  37,3D
1D00:  MOVFF  36,3C
1D04:  MOVFF  39,3F
1D08:  MOVFF  38,3E
1D0C:  BRA    1BB6
....................             update_node(node,size+csize); 
1D0E:  MOVFF  35,3C
1D12:  MOVLW  80
1D14:  MOVWF  3D
1D16:  MOVFF  37,3F
1D1A:  MOVFF  36,3E
1D1E:  MOVWF  41
1D20:  MOVFF  35,40
1D24:  RCALL  1C38
....................          } 
....................          else//not enough space for new node so use original size 
1D26:  BRA    1D42
....................          update_node(node,nsize+csize); 
1D28:  MOVFF  3A,3C
1D2C:  MOVLW  80
1D2E:  ADDWF  3B,W
1D30:  MOVWF  3D
1D32:  MOVFF  37,3F
1D36:  MOVFF  36,3E
1D3A:  MOVWF  41
1D3C:  MOVFF  3A,40
1D40:  RCALL  1C38
....................          //end if 
....................          break; 
1D42:  BRA    1D60
....................       }//end if 
....................       node=node->next; 
1D44:  MOVLW  02
1D46:  ADDWF  36,W
1D48:  MOVWF  FE9
1D4A:  MOVLW  00
1D4C:  ADDWFC 37,W
1D4E:  MOVWF  FEA
1D50:  MOVFF  FEC,03
1D54:  MOVF   FED,F
1D56:  MOVFF  FEF,36
1D5A:  MOVFF  03,37
....................    }//end while 
1D5E:  BRA    1C54
....................    if(node==NULL)// reached end without finding an appropriate node 
1D60:  MOVF   36,F
1D62:  BNZ   1D72
1D64:  MOVF   37,F
1D66:  BNZ   1D72
....................    { 
....................       //printf("\r\n Not enough memory for allocation"); 
....................       return NULL; 
1D68:  MOVLW  00
1D6A:  MOVWF  01
1D6C:  MOVWF  02
1D6E:  BRA    1D82
....................    } 
....................    else 
1D70:  BRA    1D82
....................    return (char *)node+sizeof(node_t); // return pointer to allocated space 
1D72:  MOVLW  04
1D74:  ADDWF  36,W
1D76:  MOVWF  01
1D78:  MOVLW  00
1D7A:  ADDWFC 37,W
1D7C:  MOVWF  03
1D7E:  MOVWF  02
1D80:  BRA    1D82
.................... } 
1D82:  RETLW  00
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    long nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................       if(!bit_test(node->size,pos) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(long)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+csize); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+csize); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       //printf("\r\n Not enough memory for allocation"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((long)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(long)node+sizeof(node_t);// return pointer to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    long nsize; 
....................  
....................    if(ptr==NULL) // not a valid pointer 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,pos))// node occupied 
....................       { 
....................          nsize=node->size-csize; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    long nsize,nextsize; 
....................  
....................    if(ptr==NULL)// null pointer, so malloc the req memory 
....................       malloc(size); 
....................    else if(size==0) 
....................    { 
....................    free(ptr); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,pos))// chk if valid pointer 
....................       { 
....................          nsize=node->size-csize; 
....................          temp=(long)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,pos) && (temp==((long)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+csize); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(long)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+csize); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(long)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+csize); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,pos) && (temp==((long)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+csize);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(long)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+csize);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pointer to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          malloc(size); 
....................          //return; 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <MechaBoardSettings.h> 
.................... // Things specific to MechaBoard are defined here 
.................... // You are free to change it to suit your convenience 
.................... // these settings are for Mechaboard 4.0 
....................  
....................  
.................... // define buttons 
.................... #define SW1 PIN_B4 
.................... #define SW2 PIN_B5 
.................... #define Dip1 PIN_D2 
.................... #define Dip2 PIN_D3 
....................  
....................  
.................... // define user friendly LEDs 
.................... #define Led1 PIN_D4 
.................... #define Led2 PIN_D5 
.................... #define Led3 PIN_D6 
.................... #define Led4 PIN_D7 
....................  
....................  
.................... // define Analog Input channels 
.................... #define POT 0 
.................... //#define AN0 
.................... #define AN1 1 
.................... #define AN2 2 
.................... #define AN3 3 
.................... #define AN4 4 
.................... #define AN5 5 
....................  
....................  
.................... // Define constants related to DC Motor Driver Card 
.................... #define Motor1 PIN_C2 
.................... #define Motor2 PIN_C1 
....................  
.................... #define Motor1Dir1 PIN_D0 
.................... #define Motor1Dir2 PIN_D1 
....................  
.................... #define Motor2Dir1 PIN_C0 
.................... #define Motor2Dir2 PIN_E2 
....................  
.................... #define Motor1Current PIN_E0 
.................... #define Motor2Current PIN_E1 
....................  
.................... #define EnableMotor output_high 
.................... #define DisableMotor output_low 
....................  
....................  
.................... // Custom functions to be included in the library 
....................  
.................... //Sets the state of the LEDs on B5, B3, B2, B1 based on the LS nibble on the passed value 
.................... // Among the LEDs, B5 is the LS, B1 is the MS bit 
.................... void SetLeds(int8 val) 
.................... { 
....................    // expect the lower nibble of val to contain LED state bits 
....................    #bit L1 = val.0 
....................    #bit L2 = val.1 
....................    #bit L3 = val.2 
....................    #bit L4 = val.3 
....................  
....................    output_bit(Led1, L1); 
....................    output_bit(Led2, L2); 
....................    output_bit(Led3, L3); 
....................    output_bit(Led4, L4); 
....................    return; 
.................... } 
....................  
.................... // this function takes an 8 bit integer and displays the result on  
.................... // the 4 leds to divide the 0-255 interval into 5 different range 
.................... void VuMeter(int8 val) 
.................... { 
....................    if(val > 204) { SetLeds(15); return;} 
....................    if(val > 153) { SetLeds(7); return; } 
....................    if(val > 102) { SetLeds(3); return; } 
....................    if(val > 51)    SetLeds(1); 
....................    else SetLeds(0); 
....................    return;    
.................... } 
....................  
.................... void Walker(int8 times = 1) 
.................... { 
....................    int8 i, j; 
....................    int8 valz[] = {0, 1, 3, 7, 15, 7, 3, 1, 0}; 
....................    //int8 valz[] = {0, 1, 2, 4, 8, 15, 8, 4, 2, 1, 0}; 
....................    const int wait4 = 100; 
....................     
....................    for(i=0; i<times; i++) 
....................    { 
....................       for(j=0; j<9; j++) 
....................       { 
....................          SetLeds(valz[j]); 
....................          delay_ms(wait4); 
....................       } 
....................    } 
.................... } 
....................  
.................... #include <MechaBoardUSB.h> 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     Include this when                             //// 
.................... ////                  USB Bootloader is used                           //// 
.................... ////                       on the 4550                                 //// 
.................... ////         as long as you use C18 HID USB Bootloader on 4550         //// 
.................... ////                   do NOT edit this file                           //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... #define LOADER_SIZE                 (0xFFF) 
.................... #define LOADER_START                (0) 
.................... #define LOADER_END                  (LOADER_SIZE) 
.................... #define APPLICATION_START           (LOADER_SIZE+1) 
.................... #define APPLICATION_END             (getenv("PROGRAM_MEMORY")-1) 
.................... #define APPLICATION_ISR             (APPLICATION_START+8) 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif  
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #byte    PORTB = 0xF81 
....................  
.................... #define LED_MASK(x)   ( 0x00 + (x>>2 & 0x20) + (x>>3 & 0x0E) )   
....................  
.................... #DEFINE USB_HID_DEVICE     FALSE 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_BULK  //turn on EP1 for IN bulk/interrupt transfers 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_BULK  //turn on EP1 for OUT bulk/interrupt transfers 
.................... #define EXP_SIZE  64 
.................... #define USB_EP1_TX_SIZE    EXP_SIZE  //size to allocate for the tx endpoint 1 buffer TX is to the computer 
.................... #define USB_EP1_RX_SIZE    EXP_SIZE   //size to allocate for the rx endpoint 1 buffer RX is from the computer 
....................  
.................... #include <pic18_usb.h>     //required to use USB Bulk mode 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... ////  Microchip PIC18Fxx5x Hardware layer for CCS's PIC USB driver   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes: //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor //// 
.................... ////   usb.c - USB token and request handler code                    //// 
.................... ////   usb.h - definitions, prototypes and global variables          //// 
.................... ////                                                                 //// 
.................... //// The following examples are provided by CCS:                     //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                 //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.       //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  //// 
.................... ////                      interfaces.                                //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  //// 
.................... ////                      HID Reports.                               //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom        //// 
.................... ////                    protocol requiring custom Windows drivers.   //// 
.................... ////                                                                 //// 
.................... ////   *************************  NOTE  **************************   //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on C4 or C5 depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on C3, even if you are using  //// 
.................... ////  the internal 3.3V USB regulator.                               //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   *************************  NOTE  **************************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ////    ****************   USER FUNCTIONS  ***********************   //// 
.................... ////                                                                 //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and  //// 
.................... ////              attaches the unit to the usb bus.  Enables         //// 
.................... ////              interrupts.                                        //// 
.................... ////                                                                 //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit      //// 
.................... ////              to usb bus or enable interrupts.                   //// 
.................... ////                                                                 //// 
.................... //// usb_put_packet() - Sends one packet to the host.                //// 
.................... ////                    If you need to send a message that spans     //// 
.................... ////                    more than one packet then see usb_puts() in  //// 
.................... ////                    usb.c                                        //// 
.................... ////                                                                 //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from   //// 
.................... ////               host.                                             //// 
.................... ////                                                                 //// 
.................... //// usb_rx_packet_size() - Returns the size of packet that was      //// 
.................... ////               received.  usb_kbhit() must return TRUE else      //// 
.................... ////               this is not valid.  Don't forget in USB there     //// 
.................... ////               are 0 len packets!                                //// 
.................... ////                                                                 //// 
.................... //// usb_get_packet() - Gets one packet that from the host.          //// 
.................... ////                    usb_kbhit() must return true before you call //// 
.................... ////                    this routine or your data may not be valid.  //// 
.................... ////                    Once usb_kbhit() returns true you want to    //// 
.................... ////                    call this as soon as possible to get data    //// 
.................... ////                    out of the endpoint buffer so the PC can     //// 
.................... ////                    start sending more data, if needed.          //// 
.................... ////                    This only receives one packet, if you are    //// 
.................... ////                    trying to receive a multi-packet message     //// 
.................... ////                    see usb_gets() in usb.c.                     //// 
.................... ////                                                                 //// 
.................... //// usb_detach() - De-attach USB from the system.                   //// 
.................... ////                                                                 //// 
.................... //// usb_attach() - Attach USB to the system.                        //// 
.................... ////                                                                 //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a    //// 
.................... ////                  USB cable.  A macro that looks at the defined  //// 
.................... ////                  connection sense pin.                          //// 
.................... ////                                                                 //// 
.................... //// usb_task() - Keeps track of connection sense, calling           //// 
.................... ////              usb_detach() and usb_attach() when needed.         //// 
.................... ////                                                                 //// 
.................... //// For more documentation on these functions read the comments at  //// 
.................... //// each function.                                                  //// 
.................... ////                                                                 //// 
.................... //// The other functions defined in this file are for use by the     //// 
.................... //// USB code, and is not meant to be used by the user.              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_HARDWARE__ 
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
.................... #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED==FALSE 
....................  //slow speed requires 8byte max packet size for endpoint 0 
....................  #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................  //for full speed you can still use 8bytes, but 64 will be faster 
....................  #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
.................... #endif 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define USB_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if (USB_BUFFER_NEEDED > 0x2FF) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #reserve 0x400:0x500+USB_BUFFER_NEEDED 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #ifndef USB_USE_ERROR_COUNTER 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #ifndef USB_PING_PONG_MODE 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #byte UFRML   =  0xF66 
.................... #byte UFRMH   =  0xF67 
....................  
.................... #byte UIR     =  0xF68 
.................... #BIT UIR_SOF = UIR.6 
.................... #BIT UIR_STALL = UIR.5 
.................... #BIT UIR_IDLE = UIR.4 
.................... #BIT UIR_TRN = UIR.3 
.................... #BIT UIR_ACTV = UIR.2 
.................... #BIT UIR_UERR = UIR.1 
.................... #BIT UIR_URST = UIR.0 
....................  
.................... #byte UIE     =  0xF69 
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #byte UEIR    =  0xF6A 
.................... #byte UEIE    =  0xF6B 
....................  
.................... #byte USTAT   =  0xF6C 
....................  
.................... #byte UCON    =  0xF6D 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #byte UADDR   =  0xF6E 
....................  
.................... #byte UCFG    =  0xF6F 
....................  
.................... #define  UEP0_LOC 0xF70 
....................  
.................... #byte UEP0    =  0xF70 
....................  
.................... #define USB_Buffer 0x500 
....................  
.................... #byte BD0STAT  =  0x400 
.................... #byte BD0CNT  =  0x401 
.................... #byte BD0ADRL  =  0x402 
.................... #byte BD0ADRJ  =  0x403 
....................  
.................... #define BD0STAT_LOC 0x400 
.................... #define BD0CNT_LOC  0x401 
.................... #define BD0ADRL_LOC 0x402 
.................... #define BD0ADRH_LOC 0x403 
....................  
.................... #define UEP(x) *(UEP0_LOC+x) 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    *(BD0STAT_LOC + x*8) 
....................  #define EP_BDxCNT_O(x)    *(BD0CNT_LOC + x*8) 
....................  #define EP_BDxADR_O(x)   *(int16 *)(BD0ADRL_LOC + x*8) 
....................  #define EP_BDxST_I(x)    *(BD0STAT_LOC + 4 + x*8) 
....................  #define EP_BDxCNT_I(x)    *(BD0CNT_LOC + 4 + x*8) 
....................  #define EP_BDxADR_I(x)   *(int16 *)(BD0ADRL_LOC + 4 + x*8) 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED	0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY	0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY	0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL	0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS 0x3F 
.................... #else 
....................  #define STANDARD_INTS 0x3D 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #define __USB_UCFG_UOEMON  0x40 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #define __USB_UCFG_UTRDIS  0x08 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #define __UCFG_VAL_DISABLED__ 0x08 
....................  
.................... char usb_ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_rx_buffer=0x500 
....................  
.................... char usb_ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_tx_buffer=0x500+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c 
.................... void usb_init(); 
.................... void usb_detach(); 
.................... int1 usb_put_packet(int endpoint, int * ptr, int16 len, USB_DTS_BIT tgl); 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); //marks the transmit buffer as ready for transmission 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max); 
.................... int16 usb_rx_packet_size(int8 endpoint); 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max); 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
.................... void usb_stall_ep(int8 endpoint); 
.................... void usb_unstall_ep(int8 endpoint); 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
.................... void usb_set_address(int8 address); 
.................... void usb_set_configured(int config); 
.................... void usb_disable_endpoints(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void) {  //done 
....................    UCON=0;  //disable USB hardware 
1D84:  CLRF   F6D
....................    UIE=0;   //disable USB interrupts 
1D86:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1D88:  MOVLW  08
1D8A:  MOVWF  F6F
....................    set_tris_c(*0xF94 | 0x30); 
1D8C:  MOVF   F94,W
1D8E:  IORLW  30
1D90:  MOVWF  F94
....................    usb_state=USB_STATE_DETACHED; 
1D92:  CLRF   21
1D94:  CLRF   18
1D96:  BTFSC  FF2.7
1D98:  BSF    18.7
1D9A:  BCF    FF2.7
....................    usb_token_reset();              //clear the chapter9 stack 
1D9C:  CALL   11E2
1DA0:  BTFSC  18.7
1DA2:  BSF    FF2.7
....................    __usb_kbhit_status=0; 
1DA4:  CLRF   20
1DA6:  CLRF   1F
.................... } 
1DA8:  GOTO   1DF4 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void) { 
1DAC:  CLRF   18
1DAE:  BTFSC  FF2.7
1DB0:  BSF    18.7
1DB2:  BCF    FF2.7
....................    usb_token_reset(); 
1DB4:  CALL   11E2
1DB8:  BTFSC  18.7
1DBA:  BSF    FF2.7
....................     UCON = 0; 
1DBC:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1DBE:  MOVLW  14
1DC0:  MOVWF  F6F
....................     UIE = 0;                                // Mask all USB interrupts 
1DC2:  CLRF   F69
....................     UCON_USBEN = 1;                     // Enable module & attach to bus 
1DC4:  BSF    F6D.3
....................     usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1DC6:  MOVLW  01
1DC8:  MOVWF  21
.................... } 
1DCA:  GOTO   1DD4 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: Resets and initalizes USB peripheral.  Does not attach the peripheral 
.................... /*          to the USB bus.  See usb_attach() and usb_task() on how to 
.................... /*          attach to the USB bus. 
.................... /* 
.................... /*          You must call this before any other USB code. 
.................... /* 
.................... /*          NOTE: an alternative function, usb_init(), is provided that 
.................... /*                initializes the USB and then connects. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_init_cs usb_detach 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: Keeps an eye on the connection sense pin to determine if we are 
.................... /*          attached to a USB cable or not.  If we are attached to a USB cable, 
.................... /*          initialize the USB peripheral if needed.  If we are disconnected 
.................... /*          from the USB cable, disable the USB peripheral. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, will automatically 
.................... /*                enable the USB peripheral. 
.................... /* 
.................... /*          NOTE: this enables interrupts once the USB peripheral is ready 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void) { 
....................    if (usb_attached()) { 
....................       if (UCON_USBEN==0) { 
1DCE:  BTFSC  F6D.3
1DD0:  BRA    1DD4
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1DD2:  BRA    1DAC
....................       } 
....................    } 
....................    else { 
....................       if (UCON_USBEN==1)  { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) { 
1DD4:  DECFSZ 21,W
1DD6:  BRA    1DEE
1DD8:  BTFSC  F6D.5
1DDA:  BRA    1DEE
....................       UIR=0; 
1DDC:  CLRF   F68
....................       UIE=0; 
1DDE:  CLRF   F69
....................       enable_interrupts(INT_USB); 
1DE0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1DE2:  MOVLW  C0
1DE4:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt 
1DE6:  MOVLW  11
1DE8:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1DEA:  MOVLW  02
1DEC:  MOVWF  21
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1DEE:  GOTO   1DF6 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: Resets and initalizes USB hardware.  You must call this first before 
.................... /*          using code.  Will attach the USB periperhal to the USB bus. 
.................... /* 
.................... /*          NOTE: If you are using a connection sense pin, this will wait in 
.................... /*                an infinite loop until the device is connected to a USB cable. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, this will wait 
.................... /*                in an infinte loop until the SE0 condition clears, which usually 
.................... /*                doesn't take long 
.................... /* 
.................... /*          NOTE: this enables interrupts. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void) { 
....................    usb_init_cs(); 
1DF2:  BRA    1D84
....................  
....................    do { 
....................       usb_task(); 
1DF4:  BRA    1DCE
....................    } while (usb_state != USB_STATE_POWERED); 
1DF6:  MOVF   21,W
1DF8:  SUBLW  02
1DFA:  BNZ   1DF4
.................... } 
1DFC:  GOTO   22E0 (RETURN)
....................  
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC) 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    i=EP_BDxST_I(endpoint); 
*
1900:  MOVF   5B,W
1902:  MULLW  08
1904:  MOVF   FF3,W
1906:  ADDLW  04
1908:  MOVWF  01
190A:  MOVLW  04
190C:  MOVWF  03
190E:  BTFSC  FD8.0
1910:  INCF   03,F
1912:  MOVFF  01,FE9
1916:  MOVFF  03,FEA
191A:  MOVFF  FEF,5F
....................    if (!bit_test(i,7)) { 
191E:  BTFSC  5F.7
1920:  BRA    19D8
....................  
....................       EP_BDxCNT_I(endpoint)=len; 
1922:  MOVF   5B,W
1924:  MULLW  08
1926:  MOVF   FF3,W
1928:  ADDLW  05
192A:  MOVWF  01
192C:  MOVLW  04
192E:  MOVWF  03
1930:  BTFSC  FD8.0
1932:  INCF   03,F
1934:  MOVFF  01,FE9
1938:  MOVFF  03,FEA
193C:  MOVFF  5C,FEF
....................  
....................      debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) { 
1940:  MOVF   5E,W
1942:  SUBLW  02
1944:  BNZ   1972
....................          i=EP_BDxST_I(endpoint); 
1946:  MOVF   5B,W
1948:  MULLW  08
194A:  MOVF   FF3,W
194C:  ADDLW  04
194E:  MOVWF  01
1950:  MOVLW  04
1952:  MOVWF  03
1954:  BTFSC  FD8.0
1956:  INCF   03,F
1958:  MOVFF  01,FE9
195C:  MOVFF  03,FEA
1960:  MOVFF  FEF,5F
....................          if (bit_test(i,6)) 
1964:  BTFSS  5F.6
1966:  BRA    196C
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
1968:  CLRF   5E
....................          else 
196A:  BRA    1970
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
196C:  MOVLW  01
196E:  MOVWF  5E
....................       } 
....................       else if (tgl == USB_DTS_USERX) { 
1970:  BRA    1998
1972:  MOVF   5E,W
1974:  SUBLW  04
1976:  BNZ   1998
....................          i=EP_BDxST_O(endpoint); 
1978:  MOVF   5B,W
197A:  MULLW  08
197C:  MOVFF  FF3,01
1980:  MOVLW  04
1982:  MOVFF  01,FE9
1986:  MOVWF  FEA
1988:  MOVFF  FEF,5F
....................          if (bit_test(i,6)) 
198C:  BTFSS  5F.6
198E:  BRA    1996
....................             tgl=USB_DTS_DATA1; 
1990:  MOVLW  01
1992:  MOVWF  5E
....................          else 
1994:  BRA    1998
....................             tgl=USB_DTS_DATA0; 
1996:  CLRF   5E
....................       } 
....................       if (tgl == USB_DTS_DATA1) { 
1998:  DECFSZ 5E,W
199A:  BRA    19A2
....................          i=0xC8;  //DATA1, UOWN 
199C:  MOVLW  C8
199E:  MOVWF  5F
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
19A0:  BRA    19AA
19A2:  MOVF   5E,F
19A4:  BNZ   19AA
....................          i=0x88; //DATA0, UOWN 
19A6:  MOVLW  88
19A8:  MOVWF  5F
....................       } 
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
19AA:  BTFSC  5D.0
19AC:  BSF    5F.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
19AE:  BTFSC  5D.1
19B0:  BSF    5F.1
....................  
....................       debug_usb(debug_putc," %X",i); 
....................  
....................       EP_BDxST_I(endpoint)=i;//save changes 
19B2:  MOVF   5B,W
19B4:  MULLW  08
19B6:  MOVF   FF3,W
19B8:  ADDLW  04
19BA:  MOVWF  01
19BC:  MOVLW  04
19BE:  MOVWF  03
19C0:  BTFSC  FD8.0
19C2:  INCF   03,F
19C4:  MOVFF  01,FE9
19C8:  MOVFF  03,FEA
19CC:  MOVFF  5F,FEF
....................  
....................       return(1); 
19D0:  MOVLW  01
19D2:  MOVWF  01
19D4:  BRA    19DC
....................    } 
....................     else { 
19D6:  BRA    19D8
....................          debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................    return(0); 
19D8:  MOVLW  00
19DA:  MOVWF  01
.................... } 
19DC:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_put_packet(endpoint,*ptr,len,toggle) 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to 
.................... /*        ptr - points to data to send 
.................... /*        len - amount of data to send 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only reason it will 
.................... /*         return FALSE is if because the TX buffer is still full from the last time you 
.................... /*         tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a difference 
.................... /*          between a packet and a message.  If you wanted to send a 512 byte message you 
.................... /*          would accomplish this by sending 8 64-byte packets, followed by a 0 length packet. 
.................... /*          If the last (or only packet) being sent is less than the max packet size defined 
.................... /*          in your descriptor then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message correctly. 
.................... /* 
.................... /********************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl) { //done 
....................    int16 j; 
....................    int8 i; 
....................    int8 * buff_add; 
....................  
....................    i=EP_BDxST_I(endpoint); 
*
1E54:  MOVF   48,W
1E56:  MULLW  08
1E58:  MOVF   FF3,W
1E5A:  ADDLW  04
1E5C:  MOVWF  01
1E5E:  MOVLW  04
1E60:  MOVWF  03
1E62:  BTFSC  FD8.0
1E64:  INCF   03,F
1E66:  MOVFF  01,FE9
1E6A:  MOVFF  03,FEA
1E6E:  MOVFF  FEF,50
....................    if (!bit_test(i,7)) { 
1E72:  BTFSC  50.7
1E74:  BRA    1F00
....................  
....................       buff_add=EP_BDxADR_I(endpoint); 
1E76:  MOVF   48,W
1E78:  MULLW  08
1E7A:  MOVF   FF3,W
1E7C:  ADDLW  06
1E7E:  MOVWF  01
1E80:  MOVLW  04
1E82:  MOVWF  03
1E84:  BTFSC  FD8.0
1E86:  INCF   03,F
1E88:  MOVFF  01,FE9
1E8C:  MOVFF  03,FEA
1E90:  MOVFF  FEC,03
1E94:  MOVF   FED,F
1E96:  MOVFF  FEF,51
1E9A:  MOVFF  03,52
....................  
....................       for (j=0;j<len;j++) { 
1E9E:  CLRF   4F
1EA0:  CLRF   4E
1EA2:  MOVF   4F,W
1EA4:  SUBWF  4C,W
1EA6:  BNC   1EDC
1EA8:  BNZ   1EB0
1EAA:  MOVF   4B,W
1EAC:  SUBWF  4E,W
1EAE:  BC    1EDC
....................          *buff_add=*ptr; 
1EB0:  MOVFF  49,FE9
1EB4:  MOVFF  4A,FEA
1EB8:  MOVFF  FEF,55
1EBC:  MOVFF  52,FEA
1EC0:  MOVFF  51,FE9
1EC4:  MOVFF  55,FEF
....................          buff_add++; 
1EC8:  INCF   51,F
1ECA:  BTFSC  FD8.2
1ECC:  INCF   52,F
....................          ptr++; 
1ECE:  INCF   49,F
1ED0:  BTFSC  FD8.2
1ED2:  INCF   4A,F
....................       } 
1ED4:  INCF   4E,F
1ED6:  BTFSC  FD8.2
1ED8:  INCF   4F,F
1EDA:  BRA    1EA2
1EDC:  CLRF   18
1EDE:  BTFSC  FF2.7
1EE0:  BSF    18.7
1EE2:  BCF    FF2.7
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
1EE4:  MOVFF  48,5B
1EE8:  MOVFF  4C,5D
1EEC:  MOVFF  4B,5C
1EF0:  MOVFF  4D,5E
1EF4:  RCALL  1900
1EF6:  BTFSC  18.7
1EF8:  BSF    FF2.7
1EFA:  MOVF   01,W
1EFC:  BRA    1F04
....................     } 
....................     else { 
1EFE:  BRA    1F00
....................         debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................     return(0); 
1F00:  MOVLW  00
1F02:  MOVWF  01
.................... } 
1F04:  RETLW  00
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC) 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................    int16 len; 
....................  
....................      #if USB_IGNORE_RX_DTS 
....................       if (tgl == USB_DTS_STALL) { 
....................          debug_usb(debug_putc, '*'); 
....................          i=0x84; 
....................          EP_BDxST_I(endpoint)=0x84; 
....................          return; 
....................       } 
....................       else 
....................          i=0x80; 
....................      #else 
....................       i=EP_BDxST_O(endpoint); 
*
181C:  MOVF   5B,W
181E:  MULLW  08
1820:  MOVFF  FF3,01
1824:  MOVLW  04
1826:  MOVFF  01,FE9
182A:  MOVWF  FEA
182C:  MOVFF  FEF,5D
....................       if (tgl == USB_DTS_TOGGLE) { 
1830:  MOVF   5C,W
1832:  SUBLW  02
1834:  BNZ   1842
....................          if (bit_test(i,6)) 
1836:  BTFSS  5D.6
1838:  BRA    183E
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
183A:  CLRF   5C
....................          else 
183C:  BRA    1842
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
183E:  MOVLW  01
1840:  MOVWF  5C
....................       } 
....................       if (tgl == USB_DTS_STALL) { 
1842:  MOVF   5C,W
1844:  SUBLW  03
1846:  BNZ   186C
....................          i=0x84; 
1848:  MOVLW  84
184A:  MOVWF  5D
....................          EP_BDxST_I(endpoint)=0x84; //stall both in and out endpoints 
184C:  MOVF   5B,W
184E:  MULLW  08
1850:  MOVF   FF3,W
1852:  ADDLW  04
1854:  MOVWF  01
1856:  MOVLW  04
1858:  MOVWF  03
185A:  BTFSC  FD8.0
185C:  INCF   03,F
185E:  MOVFF  01,FE9
1862:  MOVFF  03,FEA
1866:  MOVLW  84
1868:  MOVWF  FEF
....................       } 
....................       else if (tgl == USB_DTS_DATA1) { 
186A:  BRA    187E
186C:  DECFSZ 5C,W
186E:  BRA    1876
....................          i=0xC8;  //DATA1, UOWN 
1870:  MOVLW  C8
1872:  MOVWF  5D
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
1874:  BRA    187E
1876:  MOVF   5C,F
1878:  BNZ   187E
....................          i=0x88; //DATA0, UOWN 
187A:  MOVLW  88
187C:  MOVWF  5D
....................       } 
....................      #endif 
....................  
....................    bit_clear(__usb_kbhit_status,endpoint); 
187E:  CLRF   03
1880:  MOVLW  01
1882:  MOVWF  02
1884:  MOVF   5B,W
1886:  MOVWF  00
1888:  BZ    1894
188A:  BCF    FD8.0
188C:  RLCF   02,F
188E:  RLCF   03,F
1890:  DECFSZ 00,F
1892:  BRA    188A
1894:  MOVF   02,W
1896:  XORLW  FF
1898:  MOVWF  00
189A:  MOVLW  FF
189C:  XORWF  03,F
189E:  MOVF   00,W
18A0:  ANDWF  1F,F
18A2:  MOVF   03,W
18A4:  ANDWF  20,F
....................  
....................    len=usb_ep_rx_size[endpoint]; 
18A6:  BCF    FD8.0
18A8:  RLCF   5B,W
18AA:  CLRF   03
18AC:  MOVFF  FF2,60
18B0:  BCF    FF2.7
18B2:  RCALL  10CA
18B4:  TBLRD*+
18B6:  MOVFF  FF5,03
18BA:  BTFSC  x60.7
18BC:  BSF    FF2.7
18BE:  MOVWF  5E
18C0:  MOVFF  03,5F
....................    EP_BDxCNT_O(endpoint)=len; 
18C4:  MOVF   5B,W
18C6:  MULLW  08
18C8:  MOVF   FF3,W
18CA:  ADDLW  01
18CC:  MOVWF  01
18CE:  MOVLW  04
18D0:  MOVWF  03
18D2:  BTFSC  FD8.0
18D4:  INCF   03,F
18D6:  MOVFF  01,FE9
18DA:  MOVFF  03,FEA
18DE:  MOVFF  5E,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
18E2:  BTFSC  5F.0
18E4:  BSF    5D.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
18E6:  BTFSC  5F.1
18E8:  BSF    5D.1
....................  
....................  
....................    EP_BDxST_O(endpoint)=i; 
18EA:  MOVF   5B,W
18EC:  MULLW  08
18EE:  MOVFF  FF3,01
18F2:  MOVLW  04
18F4:  MOVFF  01,FE9
18F8:  MOVWF  FEA
18FA:  MOVFF  5D,FEF
.................... } 
18FE:  RETLW  00
....................  
.................... int16 usb_rx_packet_size(int8 endpoint) { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al=EP_BDxADR_O(endpoint); 
*
20A0:  MOVF   3A,W
20A2:  MULLW  08
20A4:  MOVF   FF3,W
20A6:  ADDLW  02
20A8:  MOVWF  01
20AA:  MOVLW  04
20AC:  MOVWF  03
20AE:  BTFSC  FD8.0
20B0:  INCF   03,F
20B2:  MOVFF  01,FE9
20B6:  MOVFF  03,FEA
20BA:  MOVFF  FEC,03
20BE:  MOVF   FED,F
20C0:  MOVFF  FEF,3F
20C4:  MOVFF  03,40
....................    i=EP_BDxCNT_O(endpoint); 
20C8:  MOVF   3A,W
20CA:  MULLW  08
20CC:  MOVF   FF3,W
20CE:  ADDLW  01
20D0:  MOVWF  01
20D2:  MOVLW  04
20D4:  MOVWF  03
20D6:  BTFSC  FD8.0
20D8:  INCF   03,F
20DA:  MOVFF  01,FE9
20DE:  MOVFF  03,FEA
20E2:  MOVF   FEF,W
20E4:  CLRF   03
20E6:  MOVWF  42
20E8:  MOVFF  03,43
....................    st=EP_BDxST_O(endpoint); 
20EC:  MOVF   3A,W
20EE:  MULLW  08
20F0:  MOVFF  FF3,01
20F4:  MOVLW  04
20F6:  MOVFF  01,FE9
20FA:  MOVWF  FEA
20FC:  MOVFF  FEF,41
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
2100:  BTFSC  41.0
2102:  BSF    43.0
....................    if (bit_test(st,1)) {bit_set(i,9);} 
2104:  BTFSC  41.1
2106:  BSF    43.1
....................  
....................    if (i<max) {max=i;} 
2108:  MOVF   43,W
210A:  SUBWF  3E,W
210C:  BNC   211E
210E:  BNZ   2116
2110:  MOVF   3D,W
2112:  SUBWF  42,W
2114:  BC    211E
2116:  MOVFF  43,3E
211A:  MOVFF  42,3D
....................  
....................    i=0; 
211E:  CLRF   43
2120:  CLRF   42
....................  
....................    while (i<max) { 
2122:  MOVF   43,W
2124:  SUBWF  3E,W
2126:  BNC   215C
2128:  BNZ   2130
212A:  MOVF   3D,W
212C:  SUBWF  42,W
212E:  BC    215C
....................        *ptr=*al; 
2130:  MOVFF  3F,FE9
2134:  MOVFF  40,FEA
2138:  MOVFF  FEF,46
213C:  MOVFF  3C,FEA
2140:  MOVFF  3B,FE9
2144:  MOVFF  46,FEF
....................        ptr++; 
2148:  INCF   3B,F
214A:  BTFSC  FD8.2
214C:  INCF   3C,F
....................        al++; 
214E:  INCF   3F,F
2150:  BTFSC  FD8.2
2152:  INCF   40,F
....................        i++; 
2154:  INCF   42,F
2156:  BTFSC  FD8.2
2158:  INCF   43,F
....................    } 
215A:  BRA    2122
....................  
....................    return(max); 
215C:  MOVFF  3D,01
2160:  MOVFF  3E,02
.................... } 
2164:  GOTO   217E (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Until you call usb_get_packet() the data will sit in the endpoint 
.................... /*          buffer and the PC will get NAKs when it tries to write more data 
.................... /*          to the endpoint. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max) { 
....................  
....................    max=usb_get_packet_buffer(endpoint,ptr,max); 
2168:  MOVFF  35,3A
216C:  MOVFF  37,3C
2170:  MOVFF  36,3B
2174:  MOVFF  39,3E
2178:  MOVFF  38,3D
217C:  BRA    20A0
217E:  MOVFF  02,39
2182:  MOVFF  01,38
2186:  CLRF   18
2188:  BTFSC  FF2.7
218A:  BSF    18.7
218C:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
218E:  MOVFF  35,5B
2192:  MOVLW  02
2194:  MOVWF  5C
2196:  CALL   181C
219A:  BTFSC  18.7
219C:  BSF    FF2.7
....................  
....................    return(max); 
219E:  MOVFF  38,01
21A2:  MOVFF  39,02
.................... } 
21A6:  GOTO   2316 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /********************************************************************************/ 
.................... int8 usb_tbe(int8 endpoint) { 
....................    int8 st; 
....................    st=EP_BDxST_I(endpoint); 
....................    if (!bit_test(st,7)) 
....................       return(TRUE); 
....................    return(FALSE); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_stall_ep(endpoint,direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will send STALL packet 
.................... /*          if the host tries to access this endpoint's buffer. 
.................... /* 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint) {  //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
16FC:  BTFSS  5B.7
16FE:  BCF    5C.0
1700:  BTFSC  5B.7
1702:  BSF    5C.0
....................    endpoint&=0x7F; 
1704:  BCF    5B.7
....................    if (direction) { 
1706:  BTFSS  5C.0
1708:  BRA    172A
....................       EP_BDxST_I(endpoint)=0x84; 
170A:  MOVF   5B,W
170C:  MULLW  08
170E:  MOVF   FF3,W
1710:  ADDLW  04
1712:  MOVWF  01
1714:  MOVLW  04
1716:  MOVWF  03
1718:  BTFSC  FD8.0
171A:  INCF   03,F
171C:  MOVFF  01,FE9
1720:  MOVFF  03,FEA
1724:  MOVLW  84
1726:  MOVWF  FEF
....................    } 
....................    else { 
1728:  BRA    173E
....................       EP_BDxST_O(endpoint)=0x84; 
172A:  MOVF   5B,W
172C:  MULLW  08
172E:  MOVFF  FF3,01
1732:  MOVLW  04
1734:  MOVFF  01,FE9
1738:  MOVWF  FEA
173A:  MOVLW  84
173C:  MOVWF  FEF
....................    } 
.................... } 
173E:  GOTO   17C8 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint) {   //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
16B8:  BTFSS  5B.7
16BA:  BCF    5C.0
16BC:  BTFSC  5B.7
16BE:  BSF    5C.0
....................    endpoint&=0x7F; 
16C0:  BCF    5B.7
....................    if (direction) { 
16C2:  BTFSS  5C.0
16C4:  BRA    16E6
....................       #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint)=0x80; 
....................       #else 
....................       EP_BDxST_I(endpoint)=0x88; 
16C6:  MOVF   5B,W
16C8:  MULLW  08
16CA:  MOVF   FF3,W
16CC:  ADDLW  04
16CE:  MOVWF  01
16D0:  MOVLW  04
16D2:  MOVWF  03
16D4:  BTFSC  FD8.0
16D6:  INCF   03,F
16D8:  MOVFF  01,FE9
16DC:  MOVFF  03,FEA
16E0:  MOVLW  88
16E2:  MOVWF  FEF
....................       #endif 
....................    } 
....................    else { 
16E4:  BRA    16F8
....................       EP_BDxST_O(endpoint)=0x00; 
16E6:  MOVF   5B,W
16E8:  MULLW  08
16EA:  MOVFF  FF3,01
16EE:  MOVLW  04
16F0:  MOVFF  01,FE9
16F4:  MOVWF  FEA
16F6:  CLRF   FEF
....................    } 
.................... } 
16F8:  GOTO   17BC (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_endpoint_stalled(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and Clear_Feature 
.................... /*          Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint) {   //done 
....................    int1 direction; 
....................    int8 st; 
....................    direction=bit_test(endpoint,7); 
*
1742:  BTFSS  5B.7
1744:  BCF    5C.0
1746:  BTFSC  5B.7
1748:  BSF    5C.0
....................    endpoint&=0x7F; 
174A:  BCF    5B.7
....................    if (direction) { 
174C:  BTFSS  5C.0
174E:  BRA    1770
....................       st=EP_BDxST_I(endpoint); 
1750:  MOVF   5B,W
1752:  MULLW  08
1754:  MOVF   FF3,W
1756:  ADDLW  04
1758:  MOVWF  01
175A:  MOVLW  04
175C:  MOVWF  03
175E:  BTFSC  FD8.0
1760:  INCF   03,F
1762:  MOVFF  01,FE9
1766:  MOVFF  03,FEA
176A:  MOVFF  FEF,5D
....................    } 
....................    else { 
176E:  BRA    1784
....................       st=EP_BDxST_O(endpoint); 
1770:  MOVF   5B,W
1772:  MULLW  08
1774:  MOVFF  FF3,01
1778:  MOVLW  04
177A:  MOVFF  01,FE9
177E:  MOVWF  FEA
1780:  MOVFF  FEF,5D
....................    } 
....................    return(bit_test(st,7) && bit_test(st,2)); 
1784:  BTFSS  5D.7
1786:  BRA    178C
1788:  BTFSC  5D.2
178A:  BRA    1790
178C:  MOVLW  00
178E:  BRA    1792
1790:  MOVLW  01
1792:  MOVWF  01
.................... } 
1794:  GOTO   17DC (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.  The host 
.................... /*          will now talk to use with the following address. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_address(int8 address) {   //done 
....................    UADDR=address; 
*
1A06:  MOVFF  5C,F6E
....................    if (address) { 
1A0A:  MOVF   5C,F
1A0C:  BZ    1A14
....................       usb_state=USB_STATE_ADDRESS; 
1A0E:  MOVLW  04
1A10:  MOVWF  21
....................    } 
....................    else { 
1A12:  BRA    1A18
....................       usb_state=USB_STATE_POWERED; 
1A14:  MOVLW  02
1A16:  MOVWF  21
....................    } 
.................... } 
1A18:  GOTO   1A26 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_configured(config) 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_configured(int config) { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................       if (config==0) { 
*
139E:  MOVF   5B,F
13A0:  BNZ   13AA
....................          //if config=0 then set addressed state 
....................          usb_state=USB_STATE_ADDRESS; 
13A2:  MOVLW  04
13A4:  MOVWF  21
....................          usb_disable_endpoints(); 
13A6:  RCALL  1206
....................       } 
....................       else { 
13A8:  BRA    152C
....................          usb_state=USB_STATE_CONFIGURED; //else set configed state 
13AA:  MOVLW  05
13AC:  MOVWF  21
....................          addy=(int16)0x500+(2*USB_MAX_EP0_PACKET_LENGTH); 
13AE:  MOVWF  5E
13B0:  MOVLW  80
13B2:  MOVWF  5D
....................          for (en=1;en<16;en++) { 
13B4:  MOVLW  01
13B6:  MOVWF  5C
13B8:  MOVF   5C,W
13BA:  SUBLW  0F
13BC:  BTFSS  FD8.0
13BE:  BRA    152C
....................             new_uep=0; 
13C0:  CLRF   5F
....................             if (usb_ep_rx_type[en]!=USB_ENABLE_DISABLED) { 
13C2:  CLRF   03
13C4:  MOVF   5C,W
13C6:  MOVFF  FF2,63
13CA:  BCF    FF2.7
13CC:  RCALL  10AA
13CE:  BTFSC  x63.7
13D0:  BSF    FF2.7
13D2:  XORLW  00
13D4:  BZ    1478
....................                new_uep=0x04; 
13D6:  MOVLW  04
13D8:  MOVWF  5F
....................                len=usb_ep_rx_size[en]; 
13DA:  BCF    FD8.0
13DC:  RLCF   5C,W
13DE:  CLRF   03
13E0:  MOVFF  FF2,63
13E4:  BCF    FF2.7
13E6:  RCALL  10CA
13E8:  TBLRD*+
13EA:  MOVFF  FF5,03
13EE:  BTFSC  x63.7
13F0:  BSF    FF2.7
13F2:  MOVWF  x60
13F4:  MOVFF  03,61
....................                EP_BDxCNT_O(en)=len; 
13F8:  MOVF   5C,W
13FA:  MULLW  08
13FC:  MOVF   FF3,W
13FE:  ADDLW  01
1400:  MOVWF  01
1402:  MOVLW  04
1404:  MOVWF  03
1406:  BTFSC  FD8.0
1408:  INCF   03,F
140A:  MOVFF  01,FE9
140E:  MOVFF  03,FEA
1412:  MOVFF  60,FEF
....................                EP_BDxADR_O(en)=addy; 
1416:  MOVF   5C,W
1418:  MULLW  08
141A:  MOVF   FF3,W
141C:  ADDLW  02
141E:  MOVWF  01
1420:  MOVLW  04
1422:  MOVWF  03
1424:  BTFSC  FD8.0
1426:  INCF   03,F
1428:  MOVFF  01,FE9
142C:  MOVFF  03,FEA
1430:  MOVFF  5E,FEC
1434:  MOVF   FED,F
1436:  MOVFF  5D,FEF
....................                addy+=usb_ep_rx_size[en]; 
143A:  BCF    FD8.0
143C:  RLCF   5C,W
143E:  CLRF   03
1440:  MOVFF  FF2,63
1444:  BCF    FF2.7
1446:  RCALL  10CA
1448:  TBLRD*+
144A:  MOVFF  FF5,03
144E:  BTFSC  x63.7
1450:  BSF    FF2.7
1452:  ADDWF  5D,F
1454:  MOVF   03,W
1456:  ADDWFC 5E,F
....................                #if USB_IGNORE_RX_DTS 
....................                   i=0x80; 
....................                #else 
....................                   i=0x88; 
1458:  MOVLW  88
145A:  MOVWF  x62
....................                #endif 
....................                if (bit_test(len,8)) {bit_set(i,0);} 
145C:  BTFSC  x61.0
145E:  BSF    x62.0
....................                if (bit_test(len,9)) {bit_set(i,1);} 
1460:  BTFSC  x61.1
1462:  BSF    x62.1
....................                EP_BDxST_O(en)=i; 
1464:  MOVF   5C,W
1466:  MULLW  08
1468:  MOVFF  FF3,01
146C:  MOVLW  04
146E:  MOVFF  01,FE9
1472:  MOVWF  FEA
1474:  MOVFF  62,FEF
....................             } 
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_DISABLED) { 
1478:  CLRF   03
147A:  MOVF   5C,W
147C:  MOVFF  FF2,63
1480:  BCF    FF2.7
1482:  RCALL  10AA
1484:  BTFSC  x63.7
1486:  BSF    FF2.7
1488:  XORLW  00
148A:  BZ    14EE
....................                new_uep|=0x02; 
148C:  BSF    5F.1
....................                EP_BDxADR_I(en)=addy; 
148E:  MOVF   5C,W
1490:  MULLW  08
1492:  MOVF   FF3,W
1494:  ADDLW  06
1496:  MOVWF  01
1498:  MOVLW  04
149A:  MOVWF  03
149C:  BTFSC  FD8.0
149E:  INCF   03,F
14A0:  MOVFF  01,FE9
14A4:  MOVFF  03,FEA
14A8:  MOVFF  5E,FEC
14AC:  MOVF   FED,F
14AE:  MOVFF  5D,FEF
....................                addy+=usb_ep_tx_size[en]; 
14B2:  BCF    FD8.0
14B4:  RLCF   5C,W
14B6:  CLRF   03
14B8:  MOVFF  FF2,63
14BC:  BCF    FF2.7
14BE:  RCALL  10CA
14C0:  TBLRD*+
14C2:  MOVFF  FF5,03
14C6:  BTFSC  x63.7
14C8:  BSF    FF2.7
14CA:  ADDWF  5D,F
14CC:  MOVF   03,W
14CE:  ADDWFC 5E,F
....................                EP_BDxST_I(en)=0x40; 
14D0:  MOVF   5C,W
14D2:  MULLW  08
14D4:  MOVF   FF3,W
14D6:  ADDLW  04
14D8:  MOVWF  01
14DA:  MOVLW  04
14DC:  MOVWF  03
14DE:  BTFSC  FD8.0
14E0:  INCF   03,F
14E2:  MOVFF  01,FE9
14E6:  MOVFF  03,FEA
14EA:  MOVLW  40
14EC:  MOVWF  FEF
....................             } 
....................             if (new_uep==0x06) {new_uep=0x0E;} 
14EE:  MOVF   5F,W
14F0:  SUBLW  06
14F2:  BNZ   14F8
14F4:  MOVLW  0E
14F6:  MOVWF  5F
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_ISOCHRONOUS) { 
14F8:  CLRF   03
14FA:  MOVF   5C,W
14FC:  MOVFF  FF2,63
1500:  BCF    FF2.7
1502:  RCALL  10AA
1504:  BTFSC  x63.7
1506:  BSF    FF2.7
1508:  SUBLW  02
150A:  BZ    150E
....................                new_uep|=0x10; 
150C:  BSF    5F.4
....................             } 
....................             UEP(en)=new_uep; 
150E:  MOVLW  70
1510:  ADDWF  5C,W
1512:  MOVWF  01
1514:  MOVLW  0F
1516:  MOVWF  03
1518:  BTFSC  FD8.0
151A:  INCF   03,F
151C:  MOVFF  01,FE9
1520:  MOVFF  03,FEA
1524:  MOVFF  5F,FEF
....................          } 
1528:  INCF   5C,F
152A:  BRA    13B8
....................       } 
.................... } 
152C:  GOTO   15C2 (RETURN)
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... /******************************************************************************* 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method), 
.................... /*       then you must call this function rapidly.  If there is more than 10ms 
.................... /*       latency the PC may think the USB device is stalled and disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction. 
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt. 
.................... /********************************************************************************/ 
.................... #int_usb 
.................... void usb_isr() { 
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though 
*
1B0A:  MOVF   21,F
1B0C:  BNZ   1B10
1B0E:  BRA    1B6E
....................    if (UIR) { 
1B10:  MOVF   F68,F
1B12:  BZ    1B6E
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep) 
1B14:  BTFSS  F68.2
1B16:  BRA    1B20
1B18:  BTFSS  F69.2
1B1A:  BRA    1B20
1B1C:  GOTO   11D0
....................  
....................       if (UCON_SUSPND) return; 
1B20:  BTFSS  F6D.1
1B22:  BRA    1B26
1B24:  BRA    1B6E
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
1B26:  BTFSS  F68.1
1B28:  BRA    1B32
1B2A:  BTFSS  F69.1
1B2C:  BRA    1B32
1B2E:  GOTO   11DA
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
1B32:  BTFSS  F68.0
1B34:  BRA    1B3E
1B36:  BTFSS  F69.0
1B38:  BRA    1B3E
1B3A:  GOTO   1250
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
1B3E:  BTFSS  F68.4
1B40:  BRA    1B4A
1B42:  BTFSS  F69.4
1B44:  BRA    1B4A
1B46:  GOTO   127A
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
1B4A:  BTFSS  F68.6
1B4C:  BRA    1B56
1B4E:  BTFSS  F69.6
1B50:  BRA    1B56
1B52:  GOTO   1284
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
1B56:  BTFSS  F68.5
1B58:  BRA    1B62
1B5A:  BTFSS  F69.5
1B5C:  BRA    1B62
1B5E:  GOTO   128A
....................  
....................       if (UIR_TRN && UIE_TRN) { 
1B62:  BTFSS  F68.3
1B64:  BRA    1B6E
1B66:  BTFSS  F69.3
1B68:  BRA    1B6E
....................          usb_isr_tok_dne(); 
1B6A:  BRA    1A40
....................          UIR_TRN=0;    // clear the token done interrupt., 0x190.3 
1B6C:  BCF    F68.3
....................       }    //a token has been detected (majority of isrs) 
....................    } 
.................... } 
....................  
.................... //SOF interrupt not handled.  user must add this depending on application 
1B6E:  BCF    FA1.5
1B70:  GOTO   1064
.................... void usb_isr_sof(void) { 
....................    debug_usb(debug_putc,"\r\nSOF"); 
....................    UIR_SOF=0; 
*
1284:  BCF    F68.6
.................... } 
1286:  GOTO   1B56 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints 1 thru 15 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoints(void) { 
....................    int8 i; 
....................    for (i=1;i<16;i++) { 
*
1206:  MOVLW  01
1208:  MOVWF  x63
120A:  MOVF   x63,W
120C:  SUBLW  0F
120E:  BNC   122C
....................       UEP(i)=ENDPT_DISABLED; 
1210:  MOVLW  70
1212:  ADDWF  x63,W
1214:  MOVWF  01
1216:  MOVLW  0F
1218:  MOVWF  03
121A:  BTFSC  FD8.0
121C:  INCF   03,F
121E:  MOVFF  01,FE9
1222:  MOVFF  03,FEA
1226:  CLRF   FEF
....................    } 
1228:  INCF   x63,F
122A:  BRA    120A
....................    __usb_kbhit_status=0; 
122C:  CLRF   20
122E:  CLRF   1F
.................... } 
1230:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_rst() { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR=0; 
*
1250:  CLRF   F6A
....................    UIR=0; 
1252:  CLRF   F68
....................    UEIE=0x9F; 
1254:  MOVLW  9F
1256:  MOVWF  F6B
....................    UIE=STANDARD_INTS & ~__USB_UIF_ACTIVE; 
1258:  MOVLW  39
125A:  MOVWF  F69
....................  
....................    UADDR=0; 
125C:  CLRF   F6E
....................  
....................    usb_token_reset(); 
125E:  RCALL  11E2
....................  
....................    usb_disable_endpoints(); 
1260:  RCALL  1206
....................  
....................    UEP(0)=ENDPT_CONTROL | 0x10; 
1262:  MOVLW  16
1264:  MOVWF  F70
....................  
....................    while (UIR_TRN) { 
1266:  BTFSS  F68.3
1268:  BRA    126E
....................       UIR_TRN=0;    //do this to clear out the ustat fifo 
126A:  BCF    F68.3
....................    } 
126C:  BRA    1266
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled 
126E:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
1270:  RCALL  1232
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state 
1272:  MOVLW  03
1274:  MOVWF  21
.................... } 
1276:  GOTO   1B3E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
1232:  MOVLW  40
1234:  MOVLB  4
1236:  MOVWF  x01
....................     EP_BDxADR_O(0) = 0x500; 
1238:  MOVLW  05
123A:  MOVWF  x03
123C:  CLRF   x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
123E:  MOVLW  88
1240:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
1242:  CLRF   x04
....................     EP_BDxADR_I(0) = 0x500 + (int16)USB_MAX_EP0_PACKET_LENGTH; 
1244:  MOVLW  05
1246:  MOVWF  x07
1248:  MOVLW  40
124A:  MOVWF  x06
.................... } 
124C:  MOVLB  0
124E:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr() { 
.................... #if USB_USE_ERROR_COUNTER 
....................    int ints; 
.................... #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter 
....................       debug_usbdebug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
.................... #endif 
....................  
....................    UEIR=0; 
*
11DA:  CLRF   F6A
....................    UIR_UERR=0; 
11DC:  BCF    F68.1
.................... } 
11DE:  GOTO   1B32 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_uidle() { 
....................    debug_usb(debug_putc,"I"); 
....................  
....................    UIE_ACTV=1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
127A:  BSF    F69.2
....................    UIR_IDLE=0; //clear idle interrupt flag 
127C:  BCF    F68.4
....................    UCON_SUSPND=1; //set suspend. we are now suspended 
127E:  BSF    F6D.1
.................... } 
1280:  GOTO   1B4A (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_activity() { 
....................    debug_usb(debug_putc,"A"); 
....................  
....................    UCON_SUSPND=0; //turn off low power suspending 
*
11D0:  BCF    F6D.1
....................    UIE_ACTV=0; //clear activity interupt enabling 
11D2:  BCF    F69.2
....................    UIR_ACTV=0; 
11D4:  BCF    F68.2
.................... } 
11D6:  GOTO   1B20 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_stall(void) { 
....................    debug_usb(debug_putc,"S"); 
....................  
....................    if (bit_test(UEP(0),0)) { 
*
128A:  BTFSS  F70.0
128C:  BRA    1292
....................       usb_init_ep0_setup(); 
128E:  RCALL  1232
....................       bit_clear(UEP(0),0); 
1290:  BCF    F70.0
....................    } 
....................    UIR_STALL=0; 
1292:  BCF    F68.5
.................... } 
1294:  GOTO   1B62 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_tok_dne() { 
....................    int8 en; 
....................  
....................    en=USTAT>>3; 
*
1A40:  RRCF   F6C,W
1A42:  MOVWF  5A
1A44:  RRCF   5A,F
1A46:  RRCF   5A,F
1A48:  MOVLW  1F
1A4A:  ANDWF  5A,F
....................  
....................          debug_usb(debug_putc,"T "); 
....................          debug_usb(debug_putc,"%X ", USTAT); 
....................  
....................       if (USTAT==USTAT_OUT_SETUP_E0) {   //new out or setup token in the buffer 
1A4C:  MOVF   F6C,F
1A4E:  BNZ   1AC6
....................          debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................          if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_SETUP) { 
1A50:  MOVLB  4
1A52:  MOVF   x00,W
1A54:  ANDLW  3C
1A56:  SUBLW  34
1A58:  BNZ   1A90
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
1A5A:  CLRF   x04
....................  
....................             debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................             debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................             usb_isr_tok_setup_dne(); 
1A5C:  MOVLB  0
1A5E:  BRA    17F8
....................  
....................             //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) 
....................             //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone 
....................             //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit 
....................             if (__setup_0_tx_size==0xFF) 
1A60:  INCFSZ 22,W
1A62:  BRA    1A6E
....................                usb_flush_out(0,USB_DTS_STALL); 
1A64:  CLRF   5B
1A66:  MOVLW  03
1A68:  MOVWF  5C
1A6A:  RCALL  181C
....................             else { 
1A6C:  BRA    1A8A
....................                usb_flush_out(0,USB_DTS_TOGGLE); 
1A6E:  CLRF   5B
1A70:  MOVLW  02
1A72:  MOVWF  5C
1A74:  RCALL  181C
....................                if (__setup_0_tx_size!=0xFE) { 
1A76:  MOVF   22,W
1A78:  SUBLW  FE
1A7A:  BZ    1A8A
....................                   usb_flush_in(0,__setup_0_tx_size,USB_DTS_USERX); 
1A7C:  CLRF   5B
1A7E:  CLRF   5D
1A80:  MOVFF  22,5C
1A84:  MOVLW  04
1A86:  MOVWF  5E
1A88:  RCALL  1900
....................                } 
....................             } 
....................             UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
1A8A:  BCF    F6D.4
....................          } 
....................          else if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_OUT) { 
1A8C:  BRA    1AC0
1A8E:  MOVLB  4
1A90:  MOVF   x00,W
1A92:  ANDLW  3C
1A94:  SUBLW  04
1A96:  BNZ   1AC2
....................             usb_isr_tok_out_dne(0); 
1A98:  CLRF   5B
1A9A:  MOVLB  0
1A9C:  RCALL  19DE
....................             usb_flush_out(0,USB_DTS_TOGGLE); 
1A9E:  CLRF   5B
1AA0:  MOVLW  02
1AA2:  MOVWF  5C
1AA4:  RCALL  181C
....................             if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) { 
1AA6:  MOVF   22,W
1AA8:  SUBLW  FE
1AAA:  BZ    1AC0
1AAC:  INCFSZ 22,W
1AAE:  BRA    1AB2
1AB0:  BRA    1AC0
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
1AB2:  CLRF   5B
1AB4:  CLRF   5D
1AB6:  MOVFF  22,5C
1ABA:  MOVLW  01
1ABC:  MOVWF  5E
1ABE:  RCALL  1900
1AC0:  MOVLB  4
....................             } 
....................          } 
....................       } 
....................  
....................       else if (USTAT==USTAT_IN_E0) {   //pic -> host transfer completed 
1AC2:  BRA    1B04
1AC4:  MOVLB  0
1AC6:  MOVF   F6C,W
1AC8:  SUBLW  04
1ACA:  BNZ   1AF0
....................          __setup_0_tx_size=0xFF; 
1ACC:  MOVLW  FF
1ACE:  MOVWF  22
....................          usb_isr_tok_in_dne(0); 
1AD0:  CLRF   5B
1AD2:  RCALL  1A2A
....................          if (__setup_0_tx_size!=0xFF) 
1AD4:  INCFSZ 22,W
1AD6:  BRA    1ADA
1AD8:  BRA    1AEA
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE); 
1ADA:  CLRF   5B
1ADC:  CLRF   5D
1ADE:  MOVFF  22,5C
1AE2:  MOVLW  02
1AE4:  MOVWF  5E
1AE6:  RCALL  1900
....................          else 
1AE8:  BRA    1AEE
....................             usb_init_ep0_setup(); 
1AEA:  CALL   1232
....................       } 
....................  
....................       else { 
1AEE:  BRA    1B02
....................          if (!bit_test(USTAT,2)) { 
1AF0:  BTFSC  F6C.2
1AF2:  BRA    1AFC
....................             usb_isr_tok_out_dne(en); 
1AF4:  MOVFF  5A,5B
1AF8:  RCALL  19DE
....................          } 
....................          else { 
1AFA:  BRA    1B02
....................             usb_isr_tok_in_dne(en); 
1AFC:  MOVFF  5A,5B
1B00:  RCALL  1A2A
1B02:  MOVLB  4
....................          } 
....................       } 
.................... } 
1B04:  MOVLB  0
1B06:  GOTO   1B6C (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(int len) { 
....................    __setup_0_tx_size=len; 
*
1298:  MOVFF  5E,22
.................... } 
129C:  RETLW  00
....................  
.................... void usb_request_get_data(void) { 
....................    __setup_0_tx_size=0xFE; 
.................... } 
....................  
.................... void usb_request_stall(void) { 
....................    __setup_0_tx_size=0xFF; 
129E:  MOVLW  FF
12A0:  MOVWF  22
.................... } 
12A2:  RETLW  00
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_desc_bulk.h> //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_scope.h                          //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// the USB Bulk demo (see ex_usb_scope.c)                            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////   Endpoint descriptor works if USB_EP1_TX_SIZE is 16bits          //// 
.................... ////   Endpoint descriptor works if USB_EP1_RX_SIZE is 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////   18fxx5x Initial release.                                        //// 
.................... ////                                                                   //// 
.................... //// March 21st, 2005:                                                 //// 
.................... ////   EP 0x01 and EP 0x81 now use USB_EP1_TX_SIZE and USB_EP1_RX_SIZE //// 
.................... ////      to define max packet size, to make it easier for dynamically //// 
.................... ////      changed code.                                                //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2002: Cleanup                                          //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed non-HID descriptors pointing to faulty       //// 
.................... ////                strings                                            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      32 //config+interface+class+endpoint 
....................  
....................    //configuration descriptor 
....................    const char USB_CONFIG_DESC[] = { 
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN,     //length of descriptor size 
....................          USB_DESC_CONFIG_TYPE,    //constant CONFIGURATION (0x02) 
....................          USB_TOTAL_CONFIG_LEN,0,  //size of all data returned for this config 
....................          1,                       //number of interfaces this device supports 
....................          0x01,                    //identifier for this configuration.  (IF we had more than one configurations) 
....................          0x00,                    //index of string descriptor for this configuration 
....................          0x80,                    //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 reserved and bit7=1 
....................          0x32,                    //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................  
....................    //interface descriptor 0 alt 0 
....................          USB_DESC_INTERFACE_LEN,  //length of descriptor 
....................          USB_DESC_INTERFACE_TYPE,      //constant INTERFACE (0x04) 
....................          0x00,                //number defining this interface (IF we had more than one interface) 
....................          0x00,                //alternate setting 
....................          2,       //number of endpoints, not counting endpoint 0. 
....................          0xFF,                //class code, FF = vendor defined 
....................          0xFF,                //subclass code, FF = vendor 
....................          0xFF,                //protocol code, FF = vendor 
....................          0x00,                //index of string descriptor for interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x81,              //endpoint number and direction (0x81 = EP1 IN) 
....................          0x02,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_TX_SIZE & 0xFF,USB_EP1_TX_SIZE >> 8,         //maximum packet size supported          
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x01,              //endpoint number and direction (0x01 = EP1 OUT) 
....................          0x02,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_RX_SIZE & 0xFF,USB_EP1_RX_SIZE >> 8,         //maximum packet size supported      
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................   }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   0 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   1 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    //device descriptor 
....................    const char USB_DEVICE_DESC[] ={ 
....................          USB_DESC_DEVICE_LEN,          //the length of this report 
....................          0x01,                //constant DEVICE (0x01) 
....................          0x10,0x01,           //usb version in bcd 
....................          0x00,                //class code (if 0, interface defines class.  FF is vendor defined) 
....................          0x00,                //subclass code 
....................          0x00,                //protocol code 
....................          USB_MAX_EP0_PACKET_LENGTH,   //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) 
....................          0x62,0x04,           //vendor id (0x04D8 is Microchip) 
....................          0x04,0x00,           //product id 
....................          0x00,0x01,           //device release number 
....................          0x01,                //index of string description of manufacturer. therefore we point to string_1 array (see below) 
....................          0x02,                //index of string descriptor of the product 
....................          0x00,                //index of string descriptor of serial number 
....................          USB_NUM_CONFIGURATIONS   //number of possible configurations 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string. 
.................... //offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... const char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... #define USB_STRING_DESC_COUNT sizeof(USB_STRING_DESC_OFFSET) 
....................  
.................... const char USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          48, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'M',0, 
....................          'y',0, 
....................          ' ',0, 
....................          'B',0, 
....................          'u',0, 
....................          'l',0, 
....................          'k',0, 
....................          ' ',0, 
....................          'T',0, 
....................          'r',0, 
....................          'a',0, 
....................          'n',0, 
....................          's',0, 
....................          'f',0, 
....................          'e',0, 
....................          'r',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'e',0, 
....................          'v',0, 
....................          'i',0, 
....................          'c',0, 
....................          'e',0 
.................... }; 
....................  
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>           //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... //// Many settings important to the USB API are defined in usb.h.      //// 
.................... //// See the documentation in usb.h about these settings.              //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The following functions are of use to  //// 
.................... //// the user (for more docs on the functions, read the comments at    //// 
.................... //// each function):                                                   //// 
.................... ////                                                                   //// 
.................... ////    **********************  FUNCTIONS  ***********************     //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral until you //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from     //// 
.................... ////               host.                                               //// 
.................... ////                                                                   //// 
.................... //// usb_puts() - Sends a multiple packet message to the host          //// 
.................... ////                                                                   //// 
.................... //// usb_gets() - Gets multiple packets from the host                  //// 
.................... ////                                                                   //// 
.................... //// The rest of the functions in this file are part of the USB        //// 
.................... //// interrupt service routine and are not meant to be called by the   //// 
.................... //// user.                                                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must include the following functions:                             //// 
.................... ////                                                                   //// 
.................... //// void usb_stall_ep(int8 endpoint);                                 //// 
.................... //// void usb_unstall_ep(int8 endpoint);                               //// 
.................... //// int1 usb_endpoint_stalled(int8 endpoint);                         //// 
.................... //// void usb_set_address(int8 address);                               //// 
.................... //// void usb_set_configured(int config);                              //// 
.................... //// int8 usb_get_packet(int8 endpoint, int8 * ptr, int8 max);         //// 
.................... //// int1 usb_put_packet(int endpoint, int * ptr, int len, USB_DTS_BIT toggle); //// 
.................... //// void usb_request_send_response(int8 len);                                //// 
.................... //// int1 usb_kbhit(int8 endpoint);                                    //// 
.................... ////                                                                   //// 
.................... //// CCS provides a USB peripheral hardware layer for PIC16C7x5        //// 
.................... //// (pic_usb.h), 18Fxx5x (pic18_usb.h) and National's USBN960x        //// 
.................... //// (usbn960x.c).  See these files for more documentation.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_kbhit(x) bit_test(__usb_kbhit_status,x) 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: Use this to see if device is configured / enumerated. 
.................... /***************************************************************/ 
.................... #define usb_enumerated() (USB_stack_status.curr_config) 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void) { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts(endpoint, *ptr, len, timeout) 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  If sending 
.................... /*          only one packet it is more effecient to use only usb_put_packet() 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout) { 
....................    int16 i=0; 
*
1F06:  CLRF   3B
1F08:  CLRF   3C
....................    int1 res; 
....................    int16 this_packet_len; 
....................    int16 packet_size; 
....................    int32 timeout_1us; 
....................  
....................    packet_size=usb_ep_tx_size[endpoint]; 
1F0A:  BCF    FD8.0
1F0C:  RLCF   35,W
1F0E:  CLRF   03
1F10:  MOVFF  FF2,46
1F14:  BCF    FF2.7
1F16:  CALL   10CA
1F1A:  TBLRD*+
1F1C:  MOVFF  FF5,03
1F20:  BTFSC  46.7
1F22:  BSF    FF2.7
1F24:  MOVWF  40
1F26:  MOVFF  03,41
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len) { 
1F2A:  MOVF   3C,W
1F2C:  SUBWF  39,W
1F2E:  BTFSS  FD8.0
1F30:  BRA    2008
1F32:  BNZ   1F3A
1F34:  MOVF   38,W
1F36:  SUBWF  3B,W
1F38:  BC    2008
....................       timeout_1us=(int32)timeout*1000; 
1F3A:  CLRF   49
1F3C:  CLRF   48
1F3E:  CLRF   47
1F40:  MOVFF  3A,46
1F44:  MOVFF  49,4D
1F48:  MOVFF  48,4C
1F4C:  MOVFF  47,4B
1F50:  MOVFF  3A,4A
1F54:  CLRF   51
1F56:  CLRF   50
1F58:  MOVLW  03
1F5A:  MOVWF  4F
1F5C:  MOVLW  E8
1F5E:  MOVWF  4E
1F60:  RCALL  1E00
1F62:  MOVFF  03,45
1F66:  MOVFF  02,44
1F6A:  MOVFF  01,43
1F6E:  MOVFF  00,42
....................       if ((len - i) > packet_size) {this_packet_len=packet_size;} 
1F72:  MOVF   3B,W
1F74:  SUBWF  38,W
1F76:  MOVWF  46
1F78:  MOVF   3C,W
1F7A:  SUBWFB 39,W
1F7C:  MOVWF  47
1F7E:  MOVF   41,W
1F80:  SUBWF  47,W
1F82:  BNC   1F96
1F84:  BNZ   1F8C
1F86:  MOVF   46,W
1F88:  SUBWF  40,W
1F8A:  BC    1F96
1F8C:  MOVFF  41,3F
1F90:  MOVFF  40,3E
....................       else {this_packet_len=len-i;} 
1F94:  BRA    1FA2
1F96:  MOVF   3B,W
1F98:  SUBWF  38,W
1F9A:  MOVWF  3E
1F9C:  MOVF   3C,W
1F9E:  SUBWFB 39,W
1FA0:  MOVWF  3F
....................       do { 
....................          res=usb_put_packet(endpoint,ptr + i,this_packet_len,USB_DTS_TOGGLE);   //send 64 byte packets 
1FA2:  MOVF   3B,W
1FA4:  ADDWF  36,W
1FA6:  MOVWF  46
1FA8:  MOVF   3C,W
1FAA:  ADDWFC 37,W
1FAC:  MOVWF  47
1FAE:  MOVFF  35,48
1FB2:  MOVWF  4A
1FB4:  MOVFF  46,49
1FB8:  MOVFF  3F,4C
1FBC:  MOVFF  3E,4B
1FC0:  MOVLW  02
1FC2:  MOVWF  4D
1FC4:  RCALL  1E54
1FC6:  BTFSC  01.0
1FC8:  BRA    1FCE
1FCA:  BCF    3D.0
1FCC:  BRA    1FD0
1FCE:  BSF    3D.0
....................          if (!res) { 
1FD0:  BTFSC  3D.0
1FD2:  BRA    1FEA
....................             delay_us(1); 
1FD4:  BRA    1FD6
1FD6:  BRA    1FD8
1FD8:  NOP   
....................             timeout_1us--; 
1FDA:  MOVLW  FF
1FDC:  ADDWF  42,F
1FDE:  BTFSS  FD8.0
1FE0:  ADDWF  43,F
1FE2:  BTFSS  FD8.0
1FE4:  ADDWF  44,F
1FE6:  BTFSS  FD8.0
1FE8:  ADDWF  45,F
....................          } 
....................       } while (!res && timeout_1us); 
1FEA:  BTFSC  3D.0
1FEC:  BRA    1FFE
1FEE:  MOVF   42,F
1FF0:  BNZ   1FA2
1FF2:  MOVF   43,F
1FF4:  BNZ   1FA2
1FF6:  MOVF   44,F
1FF8:  BNZ   1FA2
1FFA:  MOVF   45,F
1FFC:  BNZ   1FA2
....................       i+=packet_size; 
1FFE:  MOVF   40,W
2000:  ADDWF  3B,F
2002:  MOVF   41,W
2004:  ADDWFC 3C,F
....................    } 
2006:  BRA    1F2A
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
2008:  MOVF   38,W
200A:  SUBWF  3B,W
200C:  BNZ   2096
200E:  MOVF   39,W
2010:  SUBWF  3C,W
2012:  BNZ   2096
....................       timeout_1us=(int32)timeout*1000; 
2014:  CLRF   49
2016:  CLRF   48
2018:  CLRF   47
201A:  MOVFF  3A,46
201E:  MOVFF  49,4D
2022:  MOVFF  48,4C
2026:  MOVFF  47,4B
202A:  MOVFF  3A,4A
202E:  CLRF   51
2030:  CLRF   50
2032:  MOVLW  03
2034:  MOVWF  4F
2036:  MOVLW  E8
2038:  MOVWF  4E
203A:  RCALL  1E00
203C:  MOVFF  03,45
2040:  MOVFF  02,44
2044:  MOVFF  01,43
2048:  MOVFF  00,42
....................       do { 
....................          res=usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
204C:  MOVFF  35,48
2050:  CLRF   4A
2052:  CLRF   49
2054:  CLRF   4C
2056:  CLRF   4B
2058:  MOVLW  02
205A:  MOVWF  4D
205C:  RCALL  1E54
205E:  BTFSC  01.0
2060:  BRA    2066
2062:  BCF    3D.0
2064:  BRA    2068
2066:  BSF    3D.0
....................          if (!res) { 
2068:  BTFSC  3D.0
206A:  BRA    2082
....................             delay_us(1); 
206C:  BRA    206E
206E:  BRA    2070
2070:  NOP   
....................             timeout_1us--; 
2072:  MOVLW  FF
2074:  ADDWF  42,F
2076:  BTFSS  FD8.0
2078:  ADDWF  43,F
207A:  BTFSS  FD8.0
207C:  ADDWF  44,F
207E:  BTFSS  FD8.0
2080:  ADDWF  45,F
....................          } 
....................       } while (!res && timeout_1us); 
2082:  BTFSC  3D.0
2084:  BRA    2096
2086:  MOVF   42,F
2088:  BNZ   204C
208A:  MOVF   43,F
208C:  BNZ   204C
208E:  MOVF   44,F
2090:  BNZ   204C
2092:  MOVF   45,F
2094:  BNZ   204C
....................    } 
....................  
....................    return(res); 
2096:  MOVLW  00
2098:  BTFSC  3D.0
209A:  MOVLW  01
209C:  MOVWF  01
.................... } 
209E:  RETLW  00
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /* NOTE: NOT THOUROUGHLY TESTED.  I AM NOT EVEN SURE IF THIS IS A GOOD IDEA 
.................... /* 
.................... /*****************************************************************************/ 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout) { 
....................    int16 ret=0; 
....................    int16 to; 
....................    int16 len; 
....................    int16 packet_size; 
....................    int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output: modifies global variables USB_Interface[], in[], usb_getdesc_ptr, 
.................... /*         usb_getdesc_len, USB_status_device, USB_dev_req 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset() { 
....................    int i; 
....................  
....................  
....................  
....................       for (i=0;i<USB_MAX_NUM_INTERFACES;i++) { 
*
11E2:  CLRF   5A
11E4:  MOVF   5A,F
11E6:  BNZ   11FC
....................          USB_Interface[i]=0;   //reset each interface to default 
11E8:  CLRF   03
11EA:  MOVF   5A,W
11EC:  ADDLW  26
11EE:  MOVWF  FE9
11F0:  MOVLW  00
11F2:  ADDWFC 03,W
11F4:  MOVWF  FEA
11F6:  CLRF   FEF
....................       } 
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) { 
....................        hid_protocol[i]=1; 
....................    } 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
11F8:  INCF   5A,F
11FA:  BRA    11E4
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................     USB_stack_status.curr_config=0;      //unconfigured device 
11FC:  CLRF   1C
....................  
....................     USB_stack_status.status_device=1;    //previous state.  init at none 
11FE:  MOVLW  01
1200:  MOVWF  1D
....................     USB_stack_status.dev_req=NONE;       //previous token request state.  init at none 
1202:  CLRF   1B
.................... } 
1204:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... // 
.................... int1 usb_endpoint_is_valid(int8 endpoint) { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
1668:  BTFSS  5B.7
166A:  BCF    5C.0
166C:  BTFSC  5B.7
166E:  BSF    5C.0
....................    endpoint &= 0x7F; 
1670:  BCF    5B.7
....................    if (direction) { //IN 
1672:  BTFSS  5C.0
1674:  BRA    1696
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
1676:  CLRF   03
1678:  MOVF   5B,W
167A:  MOVFF  FF2,5D
167E:  BCF    FF2.7
1680:  RCALL  10AA
1682:  BTFSC  5D.7
1684:  BSF    FF2.7
1686:  XORLW  00
1688:  BNZ   168E
168A:  MOVLW  00
168C:  BRA    1690
168E:  MOVLW  01
1690:  MOVWF  01
1692:  BRA    16B4
....................    } 
....................    else {   //OUT 
1694:  BRA    16B4
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
1696:  CLRF   03
1698:  MOVF   5B,W
169A:  MOVFF  FF2,5D
169E:  BCF    FF2.7
16A0:  RCALL  10AA
16A2:  BTFSC  5D.7
16A4:  BSF    FF2.7
16A6:  XORLW  00
16A8:  BNZ   16AE
16AA:  MOVLW  00
16AC:  BRA    16B0
16AE:  MOVLW  01
16B0:  MOVWF  01
16B2:  BRA    16B4
....................    } 
.................... } 
16B4:  GOTO   179E (RETURN)
....................  
.................... ///---------------------------------------------------------------/// 
.................... /// Processing Message stages is the biggest portion of the ISR   /// 
.................... ///---------------------------------------------------------------/// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token.  Should be 0. 
.................... /* 
.................... /* Summary: When receiving an IN token from the PC on endpoint 0 that means the 
.................... /*          host is asking for a response from a setup token, or the next packet 
.................... /*          from a currently processing token.  (For example, a 24 byte descriptor 
.................... /*          would require 3 IN tokens if the packet size is 8 bytes.)  USB_dev_req 
.................... /*          is a global variable that defines what setup token we are currently processing. 
.................... /* 
.................... /* Part of USB interrupt service routine. 
.................... /* Only checks endpoint 0. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
1A2A:  MOVF   5B,F
1A2C:  BNZ   1A3E
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
1A2E:  DECFSZ 1B,W
1A30:  BRA    1A36
1A32:  RCALL  12A4
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
1A34:  BRA    1A3E
1A36:  MOVF   1B,W
1A38:  SUBLW  02
1A3A:  BNZ   1A3E
1A3C:  BRA    1A1C
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
1A3E:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data. 
.................... /*        This code doesn't allow reception of data from EP0. (Add later) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy incoming 
.................... /*          to the pic), but not out setup tokens.  Data is placed into a 
.................... /*          a buffer if it is empty, and the rx flag is set.  If the buffer 
.................... /*          is not empty then the overrun bit of that EP status byte is set it. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint) { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
19DE:  MOVF   5B,F
19E0:  BNZ   19E6
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      #else 
....................       usb_init_ep0_setup(); 
19E2:  RCALL  1232
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    else { 
19E4:  BRA    1A04
....................       bit_set(__usb_kbhit_status,endpoint); 
19E6:  CLRF   03
19E8:  MOVLW  01
19EA:  MOVWF  02
19EC:  MOVF   5B,W
19EE:  MOVWF  00
19F0:  BZ    19FC
19F2:  BCF    FD8.0
19F4:  RLCF   02,F
19F6:  RLCF   03,F
19F8:  DECFSZ 00,F
19FA:  BRA    19F2
19FC:  MOVF   02,W
19FE:  IORWF  1F,F
1A00:  MOVF   03,W
1A02:  IORWF  20,F
....................    } 
.................... } 
1A04:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
.................... ////// HUGE - most of our code is to read setup messages //// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the 8 bytes of the setup packet. 
.................... /* 
.................... /* Output: The DTS we expect for the next packet on OUT 0. 
.................... /* 
.................... /* Summary: This function is the start of code that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration, Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[8] now contains setup data packet, which has the following records 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
....................                                        (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet 
.................... /*                        for host-to-device, this exactly how many bytes in data packet 
.................... /*                        for device-to-host, this is the maximum bytes that can fit one packet 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void) { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
17F8:  CLRF   1B
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
17FA:  MOVLB  5
17FC:  MOVF   x00,W
17FE:  ANDLW  7F
1800:  MOVLB  0
1802:  BZ    180E
1804:  XORLW  01
1806:  BZ    1810
1808:  XORLW  03
180A:  BZ    1812
180C:  BRA    1814
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
180E:  BRA    1530
....................          break; 
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
1810:  BRA    15D2
....................          break; 
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
1812:  BRA    1798
....................          break; 
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
1814:  RCALL  129E
....................          break; 
1816:  BRA    1818
....................    } 
.................... } 
1818:  GOTO   1A60 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
1530:  MOVLB  5
1532:  MOVF   x01,W
1534:  MOVLB  0
1536:  BZ    1552
1538:  XORLW  01
153A:  BZ    1564
153C:  XORLW  02
153E:  BZ    157C
1540:  XORLW  06
1542:  BZ    1592
1544:  XORLW  03
1546:  BZ    15A0
1548:  XORLW  0E
154A:  BZ    15A2
154C:  XORLW  01
154E:  BZ    15AE
1550:  BRA    15CA
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
1552:  MOVFF  1D,540
....................             usb_ep0_tx_buffer[1]=0; 
1556:  MOVLB  5
1558:  CLRF   x41
....................             usb_request_send_response(2); 
155A:  MOVLW  02
155C:  MOVWF  5E
155E:  MOVLB  0
1560:  RCALL  1298
....................             break; 
1562:  BRA    15CE
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1564:  MOVLB  5
1566:  DECFSZ x02,W
1568:  BRA    1576
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
156A:  MOVLW  01
156C:  ANDWF  1D,F
....................                usb_put_0len_0(); 
156E:  CLRF   5E
1570:  MOVLB  0
1572:  RCALL  1298
....................             } 
....................             else 
1574:  BRA    157A
....................                usb_request_stall(); 
1576:  MOVLB  0
1578:  RCALL  129E
....................             break; 
157A:  BRA    15CE
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
157C:  MOVLB  5
157E:  DECFSZ x02,W
1580:  BRA    158C
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
1582:  BSF    1D.1
....................                usb_put_0len_0(); 
1584:  CLRF   5E
1586:  MOVLB  0
1588:  RCALL  1298
....................             } 
....................             else 
158A:  BRA    1590
....................                usb_request_stall(); 
158C:  MOVLB  0
158E:  RCALL  129E
....................             break; 
1590:  BRA    15CE
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1592:  MOVLW  02
1594:  MOVWF  1B
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1596:  MOVFF  502,23
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................          	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
159A:  CLRF   5E
159C:  RCALL  1298
....................             break; 
159E:  BRA    15CE
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
15A0:  BRA    1328
....................             break; 
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
15A2:  MOVFF  1C,540
....................             usb_request_send_response(1); 
15A6:  MOVLW  01
15A8:  MOVWF  5E
15AA:  RCALL  1298
....................             break; 
15AC:  BRA    15CE
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
15AE:  MOVLB  5
15B0:  MOVF   x02,W
15B2:  SUBLW  01
15B4:  BNC   15C6
....................                debug_usb(debug_putc,"SC"); 
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
15B6:  MOVFF  502,1C
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
15BA:  MOVFF  502,5B
15BE:  MOVLB  0
15C0:  BRA    139E
....................                usb_put_0len_0(); 
15C2:  CLRF   5E
15C4:  RCALL  1298
....................             } 
....................             break; 
15C6:  MOVLB  0
15C8:  BRA    15CE
....................  
....................       default: 
....................             usb_request_stall(); 
15CA:  RCALL  129E
....................             break; 
15CC:  BRA    15CE
....................    } 
.................... } 
15CE:  GOTO   1818 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
15D2:  MOVFF  1C,5B
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
15D6:  MOVLB  5
15D8:  MOVF   x01,W
15DA:  MOVLB  0
15DC:  BZ    15E8
15DE:  XORLW  0A
15E0:  BZ    15F8
15E2:  XORLW  01
15E4:  BZ    163C
15E6:  BRA    1660
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
15E8:  MOVLB  5
15EA:  CLRF   x40
....................             usb_ep0_tx_buffer[1]=0; 
15EC:  CLRF   x41
....................             usb_request_send_response(2); 
15EE:  MOVLW  02
15F0:  MOVWF  5E
15F2:  MOVLB  0
15F4:  RCALL  1298
....................             break; 
15F6:  BRA    1664
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
15F8:  MOVF   5B,F
15FA:  BZ    1638
15FC:  MOVLW  01
15FE:  SUBWF  5B,W
1600:  CLRF   03
1602:  MOVFF  FF2,5D
1606:  BCF    FF2.7
1608:  RCALL  113C
160A:  BTFSC  5D.7
160C:  BSF    FF2.7
160E:  MOVWF  01
1610:  MOVLB  5
1612:  SUBWF  x04,W
1614:  BTFSS  FD8.0
1616:  BRA    161C
1618:  MOVLB  0
161A:  BRA    1638
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
161C:  CLRF   03
161E:  MOVF   x04,W
1620:  ADDLW  26
1622:  MOVWF  FE9
1624:  MOVLW  00
1626:  ADDWFC 03,W
1628:  MOVWF  FEA
162A:  MOVFF  FEF,540
....................                usb_request_send_response(1);; //send byte back 
162E:  MOVLW  01
1630:  MOVWF  5E
1632:  MOVLB  0
1634:  RCALL  1298
....................             } 
....................             else 
1636:  BRA    163A
....................                usb_request_stall(); 
1638:  RCALL  129E
....................             break; 
163A:  BRA    1664
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
163C:  MOVF   5B,F
163E:  BZ    165C
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1640:  CLRF   03
1642:  MOVLB  5
1644:  MOVF   x04,W
1646:  ADDLW  26
1648:  MOVWF  FE9
164A:  MOVLW  00
164C:  ADDWFC 03,W
164E:  MOVWF  FEA
1650:  MOVFF  502,FEF
....................                usb_put_0len_0(); 
1654:  CLRF   5E
1656:  MOVLB  0
1658:  RCALL  1298
....................             } 
....................             else 
165A:  BRA    165E
....................                usb_request_stall(); 
165C:  RCALL  129E
....................             break; 
165E:  BRA    1664
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1660:  RCALL  129E
....................             break; 
1662:  BRA    1664
....................    } 
.................... } 
1664:  GOTO   1818 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
1798:  MOVFF  504,5B
179C:  BRA    1668
179E:  MOVF   01,F
17A0:  BZ    17F4
....................       switch(usb_ep0_rx_buffer[1]) { 
17A2:  MOVLB  5
17A4:  MOVF   x01,W
17A6:  XORLW  01
17A8:  MOVLB  0
17AA:  BZ    17B6
17AC:  XORLW  02
17AE:  BZ    17C2
17B0:  XORLW  03
17B2:  BZ    17CE
17B4:  BRA    17F0
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
17B6:  MOVFF  504,5B
17BA:  BRA    16B8
....................                usb_put_0len_0(); 
17BC:  CLRF   5E
17BE:  RCALL  1298
....................                break; 
17C0:  BRA    17F4
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
17C2:  MOVFF  504,5B
17C6:  BRA    16FC
....................                      usb_put_0len_0(); 
17C8:  CLRF   5E
17CA:  RCALL  1298
....................                      break; 
17CC:  BRA    17F4
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
17CE:  MOVLB  5
17D0:  CLRF   x40
....................                usb_ep0_tx_buffer[1]=0; 
17D2:  CLRF   x41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
17D4:  MOVFF  504,5B
17D8:  MOVLB  0
17DA:  BRA    1742
17DC:  MOVF   01,F
17DE:  BZ    17E8
....................                   usb_ep0_tx_buffer[0]=1; 
17E0:  MOVLW  01
17E2:  MOVLB  5
17E4:  MOVWF  x40
17E6:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
17E8:  MOVLW  02
17EA:  MOVWF  5E
17EC:  RCALL  1298
....................                break; 
17EE:  BRA    17F4
....................  
....................          default: 
....................             usb_request_stall(); 
17F0:  RCALL  129E
....................             break; 
17F2:  BRA    17F4
....................       } 
....................    } 
.................... } 
17F4:  GOTO   1818 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1328:  CLRF   24
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
132A:  CLRF   1E
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
132C:  MOVLB  5
132E:  MOVF   x03,W
1330:  XORLW  01
1332:  MOVLB  0
1334:  BZ    1340
1336:  XORLW  03
1338:  BZ    134A
133A:  XORLW  01
133C:  BZ    1350
133E:  BRA    137E
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
1340:  MOVLW  12
1342:  MOVWF  25
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
1344:  MOVLW  03
1346:  MOVWF  1E
....................             break; 
1348:  BRA    1382
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
134A:  MOVLW  20
134C:  MOVWF  25
....................             break; 
134E:  BRA    1382
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
1350:  MOVLW  02
1352:  MOVWF  1E
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
1354:  CLRF   03
1356:  MOVLB  5
1358:  MOVF   x02,W
135A:  MOVFF  FF2,5B
135E:  BCF    FF2.7
1360:  MOVLB  0
1362:  RCALL  1170
1364:  BTFSC  5B.7
1366:  BSF    FF2.7
1368:  MOVWF  24
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
136A:  CLRF   03
136C:  MOVF   24,W
136E:  MOVFF  FF2,5B
1372:  BCF    FF2.7
1374:  RCALL  1184
1376:  BTFSC  5B.7
1378:  BSF    FF2.7
137A:  MOVWF  25
....................             break; 
137C:  BRA    1382
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][0]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
....................  
....................  
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
137E:  RCALL  129E
....................             return; 
1380:  BRA    139A
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1382:  MOVLB  5
1384:  MOVF   x07,F
1386:  BNZ   1392
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
1388:  MOVF   25,W
138A:  SUBWF  x06,W
138C:  BC    1392
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
138E:  MOVFF  506,25
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1392:  MOVLW  01
1394:  MOVWF  1B
....................    usb_copy_desc_seg_to_ep(); 
1396:  MOVLB  0
1398:  RCALL  12A4
.................... } 
139A:  GOTO   15CE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
.................... 	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
*
1A1C:  CLRF   1C
....................  
....................    #ifdef __PIC__ 
.................... 	USB_stack_status.dev_req=NONE;  // no request pending 
1A1E:  CLRF   1B
....................    usb_set_address(USB_address_pending); 
1A20:  MOVFF  23,5C
1A24:  BRA    1A06
....................    #endif 
.................... } 
1A26:  GOTO   1A3E (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    int i=0; 
*
12A4:  CLRF   5C
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
12A6:  MOVF   25,F
12A8:  BZ    1314
12AA:  MOVF   5C,W
12AC:  SUBLW  3F
12AE:  BNC   1314
....................       switch(USB_stack_status.getdesc_type) { 
12B0:  MOVF   1E,W
12B2:  BZ    12BE
12B4:  XORLW  02
12B6:  BZ    12D2
12B8:  XORLW  01
12BA:  BZ    12E6
12BC:  BRA    12FA
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
12BE:  CLRF   03
12C0:  MOVF   24,W
12C2:  MOVFF  FF2,5E
12C6:  BCF    FF2.7
12C8:  RCALL  110C
12CA:  BTFSC  5E.7
12CC:  BSF    FF2.7
12CE:  MOVWF  5D
....................             break; 
12D0:  BRA    12FA
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
12D2:  CLRF   03
12D4:  MOVF   24,W
12D6:  MOVFF  FF2,5E
12DA:  BCF    FF2.7
12DC:  RCALL  1184
12DE:  BTFSC  5E.7
12E0:  BSF    FF2.7
12E2:  MOVWF  5D
....................             break; 
12E4:  BRA    12FA
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
12E6:  CLRF   03
12E8:  MOVF   24,W
12EA:  MOVFF  FF2,5E
12EE:  BCF    FF2.7
12F0:  RCALL  114E
12F2:  BTFSC  5E.7
12F4:  BSF    FF2.7
12F6:  MOVWF  5D
....................             break; 
12F8:  BRA    12FA
....................       } 
....................       usb_getdesc_ptr++; 
12FA:  INCF   24,F
....................       usb_getdesc_len--; 
12FC:  DECF   25,F
....................       usb_ep0_tx_buffer[i++]=c; 
12FE:  MOVF   5C,W
1300:  INCF   5C,F
1302:  CLRF   03
1304:  ADDLW  40
1306:  MOVWF  FE9
1308:  MOVLW  05
130A:  ADDWFC 03,W
130C:  MOVWF  FEA
130E:  MOVFF  5D,FEF
....................    } 
1312:  BRA    12A6
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1314:  MOVF   25,F
1316:  BNZ   1320
1318:  MOVF   5C,W
131A:  SUBLW  40
131C:  BZ    1320
....................          USB_stack_status.dev_req = NONE; 
131E:  CLRF   1B
....................    } 
....................  
....................    usb_request_send_response(i); 
1320:  MOVFF  5C,5E
1324:  RCALL  1298
.................... } 
1326:  RETLW  00
....................  
.................... #ENDIF 
....................  
.................... //#include <usb_desc_mouse.h> 
....................  
.................... #define DATA_LENGTH 64     //length of the data get 
....................  
.................... int8 a,b,c,d,i,j; 
.................... //int8 x; 
....................  
.................... int8* data; 
.................... int8* sdata; 
....................  
.................... #int_ext 
.................... void ext_kesme() 
.................... { 
.................... j = 1; 
*
1B74:  MOVLW  01
1B76:  MOVWF  2C
.................... } 
....................  
1B78:  BCF    FF2.1
1B7A:  GOTO   1064
.................... void one_step_forward() 
.................... { 
....................  
.................... output_high(pin_b2); 
.................... delay_ms(10); 
.................... output_low(pin_b2); 
.................... delay_ms(10); 
.................... } 
....................  
.................... void one_step_backward() 
.................... { 
....................  
.................... output_high(pin_b2); 
*
21D0:  BCF    F93.2
21D2:  BSF    F8A.2
.................... delay_ms(20); 
21D4:  MOVLW  14
21D6:  MOVWF  35
21D8:  RCALL  21AA
.................... output_low(pin_b2); 
21DA:  BCF    F93.2
21DC:  BCF    F8A.2
.................... delay_ms(20); 
21DE:  MOVLW  14
21E0:  MOVWF  35
21E2:  RCALL  21AA
.................... } 
21E4:  RETLW  00
....................  
.................... void finished() 
.................... { 
.................... delay_ms(10); 
21E6:  MOVLW  0A
21E8:  MOVWF  35
21EA:  RCALL  21AA
.................... sdata[1] = 1; 
21EC:  MOVLW  01
21EE:  ADDWF  2F,W
21F0:  MOVWF  FE9
21F2:  MOVLW  00
21F4:  ADDWFC 30,W
21F6:  MOVWF  FEA
21F8:  MOVLW  01
21FA:  MOVWF  FEF
.................... usb_puts(1,sdata,25,0); 
21FC:  MOVWF  35
21FE:  MOVFF  30,37
2202:  MOVFF  2F,36
2206:  CLRF   39
2208:  MOVLW  19
220A:  MOVWF  38
220C:  CLRF   3A
220E:  RCALL  1F06
.................... delay_ms(10); 
2210:  MOVLW  0A
2212:  MOVWF  35
2214:  RCALL  21AA
.................... } 
2216:  GOTO   238E (RETURN)
....................  
.................... void measure() 
.................... { 
.................... sdata[2] = 1; 
.................... usb_puts(1,sdata,25,0); 
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void main() 
.................... { 
221A:  CLRF   FF8
221C:  BCF    FD0.7
221E:  BSF    0D.7
2220:  CLRF   1A
2222:  MOVLW  66
2224:  MOVWF  19
2226:  MOVLW  03
2228:  MOVWF  x67
222A:  MOVLW  96
222C:  MOVWF  x66
222E:  MOVLW  06
2230:  MOVWF  x69
2232:  MOVLW  01
2234:  MOVWF  x68
2236:  MOVLB  6
2238:  MOVWF  x02
223A:  MOVLW  FB
223C:  MOVWF  x01
223E:  CLRF   x04
2240:  CLRF   x03
2242:  MOVLB  0
2244:  CLRF   FEA
2246:  CLRF   FE9
2248:  BSF    FB8.3
224A:  MOVLW  08
224C:  MOVWF  FAF
224E:  MOVLW  02
2250:  MOVWF  FB0
2252:  MOVLW  A6
2254:  MOVWF  FAC
2256:  MOVLW  90
2258:  MOVWF  FAB
225A:  MOVF   FC1,W
225C:  ANDLW  C0
225E:  IORLW  0F
2260:  MOVWF  FC1
2262:  MOVLW  07
2264:  MOVWF  FB4
2266:  CLRF   21
2268:  CLRF   25
.................... int16 st,x; 
.................... data=(int8*) malloc(DATA_LENGTH); 
226A:  MOVLW  40
226C:  MOVWF  35
226E:  RCALL  1C4C
2270:  MOVFF  02,2E
2274:  MOVFF  01,2D
.................... sdata=(int8*) malloc(DATA_LENGTH); 
2278:  MOVLW  40
227A:  MOVWF  35
227C:  RCALL  1C4C
227E:  MOVFF  02,30
2282:  MOVFF  01,2F
....................     
....................    setup_adc_ports(AN0|VSS_VDD); 
2286:  MOVF   FC1,W
2288:  ANDLW  C0
228A:  IORLW  0E
228C:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL); 
228E:  BSF    FC0.0
2290:  BSF    FC0.1
2292:  BSF    FC0.2
2294:  BSF    FC0.7
2296:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
2298:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
229A:  BCF    FC6.5
229C:  BCF    F94.7
229E:  BSF    F93.0
22A0:  BCF    F93.1
22A2:  MOVLW  01
22A4:  MOVWF  FC6
22A6:  MOVLW  00
22A8:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
22AA:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
22AC:  MOVLW  80
22AE:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
22B0:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
22B2:  MOVLW  00
22B4:  MOVWF  FCA
22B6:  MOVLW  00
22B8:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
22BA:  MOVF   FB1,W
22BC:  ANDLW  48
22BE:  MOVWF  FB1
....................    setup_comparator(NC_NC_NC_NC); 
22C0:  MOVLW  07
22C2:  MOVWF  FB4
22C4:  MOVF   F92,W
22C6:  MOVLW  10
22C8:  MOVWF  00
22CA:  DECFSZ 00,F
22CC:  BRA    22CA
22CE:  NOP   
22D0:  MOVF   FB4,W
22D2:  BCF    FA1.6
....................    setup_vref(FALSE); 
22D4:  CLRF   FB5
.................... //Setup_Oscillator parameter not selected from Intr Oscillotar Config tab 
....................  
....................    // TODO: USER CODE!! 
....................     
....................    ext_int_edge(H_TO_L); 
22D6:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
22D8:  BSF    FF2.4
....................    enable_interrupts(global); 
22DA:  MOVLW  C0
22DC:  IORWF  FF2,F
....................     
....................     
....................    usb_init(); 
22DE:  BRA    1DF2
....................     
....................    while(true) 
....................    {        
....................       if(usb_enumerated()) 
22E0:  MOVF   1C,F
22E2:  BZ    2390
....................       { 
....................        again:   
....................             usb_puts(1,sdata,25,0);     
22E4:  MOVLW  01
22E6:  MOVWF  35
22E8:  MOVFF  30,37
22EC:  MOVFF  2F,36
22F0:  CLRF   39
22F2:  MOVLW  19
22F4:  MOVWF  38
22F6:  CLRF   3A
22F8:  RCALL  1F06
....................             output_high((led3)); 
22FA:  BCF    F95.6
22FC:  BSF    F8C.6
....................  
....................             if ( usb_kbhit(1) ) 
22FE:  BTFSS  1F.1
2300:  BRA    238E
....................             {           
....................             usb_get_packet(1,data,8); 
2302:  MOVLW  01
2304:  MOVWF  35
2306:  MOVFF  2E,37
230A:  MOVFF  2D,36
230E:  CLRF   39
2310:  MOVLW  08
2312:  MOVWF  38
2314:  BRA    2168
....................                      a = data[1]; 
2316:  MOVLW  01
2318:  ADDWF  2D,W
231A:  MOVWF  FE9
231C:  MOVLW  00
231E:  ADDWFC 2E,W
2320:  MOVWF  FEA
2322:  MOVFF  FEF,27
....................                      b = data[2]; 
2326:  MOVLW  02
2328:  ADDWF  2D,W
232A:  MOVWF  FE9
232C:  MOVLW  00
232E:  ADDWFC 2E,W
2330:  MOVWF  FEA
2332:  MOVFF  FEF,28
....................                      c = data[3]; 
2336:  MOVLW  03
2338:  ADDWF  2D,W
233A:  MOVWF  FE9
233C:  MOVLW  00
233E:  ADDWFC 2E,W
2340:  MOVWF  FEA
2342:  MOVFF  FEF,29
....................                      d = data[4];  
2346:  MOVLW  04
2348:  ADDWF  2D,W
234A:  MOVWF  FE9
234C:  MOVLW  00
234E:  ADDWFC 2E,W
2350:  MOVWF  FEA
2352:  MOVFF  FEF,2A
....................                      i = data[5]; 
2356:  MOVLW  05
2358:  ADDWF  2D,W
235A:  MOVWF  FE9
235C:  MOVLW  00
235E:  ADDWFC 2E,W
2360:  MOVWF  FEA
2362:  MOVFF  FEF,2B
....................                       
....................                      if(d == 1) 
2366:  DECFSZ 2A,W
2368:  BRA    2370
....................                      { 
....................                      output_high(pin_b3); 
236A:  BCF    F93.3
236C:  BSF    F8A.3
....................  /*                    st=83*a; 
....................                      for (x = 0; x < st;x++) one_step_forward();                    
....................  
....................                      delay_ms(1000); 
....................                      st = 83*c; 
....................                       
....................                      for (j = 0; j <= i; j++) 
....................                      { 
....................                         for (x = 0; x < st; x++)  
....................                         { 
....................                            one_step_forward(); 
....................                         } 
....................                         delay_ms(2000); 
....................                         measure(); 
....................                      } 
....................                      */ 
....................                      }   
....................                       
....................                      else if (d == 2) 
236E:  BRA    238C
2370:  MOVF   2A,W
2372:  SUBLW  02
2374:  BNZ   2384
....................                      { 
....................                      j = 0; 
2376:  CLRF   2C
....................                      while(1) 
....................                      { 
....................                      one_step_backward(); 
2378:  RCALL  21D0
....................                      if (j == 1) break; 
237A:  DECFSZ 2C,W
237C:  BRA    2380
237E:  BRA    2382
....................                       
....................                      } 
2380:  BRA    2378
....................                      } 
....................                      else if (d == 3) 
2382:  BRA    238C
2384:  MOVF   2A,W
2386:  SUBLW  03
2388:  BNZ   238C
....................                      { 
....................                      one_step_backward(); 
238A:  RCALL  21D0
....................                      } 
....................  
....................                      finished(); 
238C:  BRA    21E6
....................             } 
....................              
....................             goto again; 
238E:  BRA    22E4
....................    } 
....................    } 
2390:  BRA    22E0
.................... } 
....................  
....................  
2392:  SLEEP 

Configuration Fuses:
   Word  1: C03F   XT IESO FCMEN PLL12 CPUDIV4 USBDIV
   Word  2: 0E3F   BROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8700   PBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 00E5   STVREN NODEBUG LVP XINST ICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
